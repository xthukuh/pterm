<?php

/**
 * =============================================================================
 * NCMS P-Term ~ By @xthukuh (https://github.com/xthukuh)
 * =============================================================================
 */


if (!defined('P_TERM')) define('P_TERM', __FILE__);

#================================  !_main    =================================

//target file
$target = defined('P_TERM') ? P_TERM : null;
if (!($target && is_file($target))) _failure($target ? "Invalid target file (\P_TERM=$target)" : 'Undefined target file (\P_TERM)');
$target_arg = strpos($target, ' ') !== false ? '"' . $target . "'" : $target;

//set options
$version = '1.0.0';
$cwd = getcwd();
$options = [
	'title' => 'P-TERM v' . $version,
	'version' => $version,
	'mypid' => getmypid(),
	'stdout' => ($tmp = '__pterm.xx.log'),
	'log_file' => $cwd . '/' . $tmp,
	'cache_file' => $cwd . '/__pterm.xx.cache',
	'composer_file' => $cwd . '/composer',
	'target' => $target,
	'target_arg' => $target_arg,
	'cwd' => $cwd,
	'cmd' => null,
	'resume' => null,
	'page' => 0,
	'is_console' => Process::is_console(),
];
if (isset($argv) && is_array($argv) && ($len = count($argv))){
	if ($len > 1){
		$val = array_slice($argv, 1);
		if ($val = trim(implode(' ', $val))) $options['cmd'] = $val;
	}
}
else {
	$options['method'] = $method = isset($_SERVER) && isset($_SERVER['REQUEST_METHOD']) ? strtolower($_SERVER['REQUEST_METHOD']) : null;
	if ($method === 'get') $options['page'] = 1;
	if (isset($_REQUEST) && is_array($_REQUEST) && !empty($_REQUEST)){
		if ($method === 'get') $options['page'] = -1;
		if (
			in_array($method, ['get', 'post'])
			&& array_key_exists('cmd', $_REQUEST)
			&& ($val = trim($_REQUEST['cmd']))
		){
			$options['cmd'] = $val;
			$options['page'] = 0;
		}
	}
}
$GLOBALS['__options__'] = $options;

//handle command
if ($cmd = _option('cmd')){
	switch (strtolower($cmd)){
		
		//options
		case 'options':
			_echo(_option());
			break;
		
		//exit
		case 'exit':
			break;

		//php
		case 'php':
			_echo('- PHP_EXE: ' . Process::find_php(), 1, 0);
			break;
		
		//test requirements
		case 'requirements':
			_run_bg('requirements-worker', 1);
			break;
		case 'requirements-worker':
			_check_requirements();
			break;
		
		//test lines
		case 'test':
			_run_bg('test-worker', 1);
			break;
		case 'test-worker':
			_test_lines();
			break;
		
		//install/update composer
		case 'install-composer':
			_run_bg('install-composer-worker', 1);
			break;
		case 'install-composer-worker':
			_install_composer();
			break;
		
		//resume running - buffer
		case 'resume':
			_output();
			break;
		
		//cancel running
		case 'cancel':
			_cache_get(-1, 1);
			break;
		
		//clear cache
		case 'clear':
			if (_option('is_console') === 1) sleep(1);
			_cache_get(1);
			break;
		
		//custom command
		default:
			_run_bg($cmd);
			break;
	}

	//exit - done
	exit;
}

//redirect - html page
if (($page = _option('page')) < 0){
	_redirect();
	exit;
}

//exit - no html/unsupported
if (!$page) exit(2);

//html page
_option('resume', _cache_get(-1));

#================================  !Process  =================================

/**
 * Process Wrapper
 * 
 * - By @xthukuh [https://github.com/xthukuh]
 * - run commands with (proc_open/shell_exec)
 * - read file/pipe resource output buffer with callback
 * - get error messages on failures
 * - run background process and get child PID
 * - check if PID exists/kill PID process
 * - set custom PHP executable path globally: $GLOBALS['__PHP_EXE__']
 */

class Process
{
	/**
	 * exe suffixes.
	 * 
	 * @var array
	 */
	const EXE_SUFFIXES = ['.EXE', '.BAT', '.CMD', '.COM'];

	/**
	 * process options (proc_open args)
	 * 
	 * - REF: https://www.php.net/manual/en/function.proc-open.php
	 * 
	 * @var array
	 */
	const OPTIONS = [
		'descriptor_spec' => null,	//(array) file descriptors [default: []/self::DESCRIPTOR_SPEC]
		'cwd' => null,				//(string) working directory [default: null/getcwd()]
		'env_vars' => null,			//(assoc array) environment variables [default: null to use getenv()] (note: putenv('KEY=VALUE'))
		'other_options' => null,	//(assoc array) other options [default: null] (i.e. for windows ~ self::WIN_OPTIONS)
	];

	/**
	 * default file descriptors
	 * 
	 * @var array
	 */
	const DESCRIPTOR_SPEC = [
		0 => ['pipe', 'r'],	//stdin
		1 => ['pipe', 'w'],	//stdout
		2 => ['pipe', 'w'],	//stderr
	];

	/**
	 * default windows platform options (other_options).
	 * 
	 * @var array
	 */
	const WIN_OPTIONS = [
		'suppress_errors' => false,			//suppresses errors generated by this function when it's set to true
		'bypass_shell' => false,			//bypass cmd.exe shell when set to true
		'blocking_pipes' => false,			//force blocking pipes when set to true
		'create_process_group' => false,	//allow the child process to handle CTRL events when set to true
		'create_new_console' => false,		//the new process has a new console, instead of inheriting its parent's console
	];

	/**
	 * process error message (if failed)
	 * 
	 * @var string
	 */
	private $_error;

	/**
	 * process state (one of: [null, 'failing', 'failed', 'opening', 'open', 'closing', 'closed', 'shutdown'])
	 * 
	 * @var string
	 */
	private $_state;

	/**
	 * process config data (see static::config())
	 * 
	 * @var array
	 */
	private $_config;

	/**
	 * process resource.
	 * 
	 * @var resource
	 */
	private $_process;

	/**
	 * process resource pipes
	 * 
	 * @var array
	 */
	private $_pipes;

	/**
	 * exit result code (proc_close() result)
	 * 
	 * @var int
	 */
	private $_exit;

	/**
	 * opened process ID (PID: end($this -> pids))
	 * 
	 * @var int
	 */
	private $_pid;

	/**
	 * opened processes ID (PID array)
	 * 
	 * @var array
	 */
	private $_pids;

	/**
	 * new instance
	 * 
	 * @param  string	$cmd		- command line string
	 * @param  array	$options	- process options (proc_open args)
	 * @param  bool		$background	- process runs in the background
	 * @return void
	 */
	public function __construct($cmd, $options=null, $background=false){
		$config = static::config($cmd, $options, $background, $_as_win=null, $error);
		if (!$config) $this -> _failure("Construct config failure: $error");
		else $this -> _config = $config;
	}

	/**
	 * process fail handler (close running)
	 * 
	 * @param  $error  - error message
	 * @return false
	 */
	private function _failure($error){
		$this -> _status = 'failing';
		$this -> close(1);
		$this -> _error = $error;
		$this -> _status = 'failed';
		return false;
	}
	
	/**
	 * get property value
	 * 
	 * @param  string  $name	- property name
	 * @return mixed
	 */
	public function __get($name){
		static $props = ['error', 'state', 'config', 'exit', 'pid', 'pids'];
		if (in_array($name, $props)){
			if (property_exists($this, $prop = "$name")) return $this -> {$prop};
			if (property_exists($this, $prop = "_$name")) return $this -> {$prop};
		}
		throw new Exception(sprintf('Property name "%s" is not available.', $name));
	}

	/**
	 * close process (proc_close)
	 * 
	 * @param  bool	$kill	- Kill running process.
	 * @return void
	 */
	public function close($kill=false){
		$kill = !!$kill;
		
		//closing
		if (strpos($state = $this -> _state, 'open') !== false) $this -> _state = $state = 'closing';
		elseif (strpos($state, 'clos') !== false) return; //cancel - already closing/closed
		
		//kill running
		if ($kill){
			$last = null;
			while ($pid = $this -> running()){
				static::kill($pid);
				if ($pid === $last) break;
				$last = $pid;
			}
		}

		//close pipes
		if (is_array($this -> _pipes)){
			foreach ($this -> _pipes as $i => &$pipe){
				if (is_resource($pipe)) fclose($pipe);
			}
			$this -> _pipes = null;
		}

		//close process
		if (is_resource($this -> _process)){
			$this -> _exit = $exit = proc_close($this -> _process);
			$this -> _process = null;
		}

		//closed state
		if ($state === 'closing') $this -> _state = 'closed';
	}

	/**
	 * shutdown open process
	 * 
	 * @return void
	 */
	public function shutdown(){
		if ($this -> _state !== 'open') return; //cancel - not open
		$this -> _state = 'shutdown';
		$this -> close(1);
	}

	/**
	 * process status (proc_get_status).
	 * 
	 * @param  int  $pid		- ByRef process pid.
	 * @param  int  $running	- ByRef (int/bool) process is running.
	 * @return array
	 */
	public function status(&$pid=null, &$running=null){
		$pid = null;
		$running = null;
		$status = is_resource($this -> _process) && is_array($val = proc_get_status($this -> _process)) ? $val : [];
		if (array_key_exists($key = 'pid', $status) && ($val = static::pid($status[$key]))) $pid = $val;
		if (array_key_exists($key = 'running', $status)) $running = (int) (!!$status[$key]);
		return $status;
	}
	
	/**
	 * open process (proc_open/shell_exec (unix/linux))
	 * 
	 * @param  bool	$child_pid	- get child PIDs (always enabled for $background=true).
	 * @return null|bool		- null if cancelled (ignored) | true on success | false on error
	 */
	public function open($child_pid=false){
		$child_pid = !!$child_pid;
		
		//check config
		if (!($config = $this -> _config)) return $this -> _failure(trim('Open process config is undefined. ' . $this -> _error));
		if (($background = $config['background']) && !$child_pid) $child_pid = 1;
		
		//opening
		if (($state = $this -> _state) === 'opening') return; //cancel - already opening
		if ($state === 'open') $this -> close(1);
		$this -> _state = 'opening';
		
		//reset props
		$this -> _process = null;
		$this -> _pipes = null;
		$this -> _exit = null;
		$this -> _pid = null;
		$this -> _pids = null;

		//open command
		$as_win = $config['as_win'];
		$command = $config['command'];
		
		//shell_exec - background process linux/unix
		if ($background && !$as_win){
			if ($pid = static::pid($out = shell_exec($command))){
				$this -> _state = 'open';
				$this -> _exit = 0;
				$this -> _pid = $pid;
				$this -> _pids = [$pid];
				return true;
			}
		}
		
		//proc_open - default
		$this -> _process = proc_open(
			$command,
			$config['descriptor_spec'],
			$this -> _pipes,
			$config['cwd'],
			$config['env_vars'],
			$config['other_options'],
		);
		if (!is_resource($this -> _process)) return $this -> _failure(sprintf('proc_open failure. (%s)', $command));
		if (!(!empty($this -> status($pid, $running)) && $pid)) return $this -> _failure(sprintf('Process status/pid failure. (%s)', $command));
		$this -> _pid = $pid;
		$this -> _pids = [$pid];
		if ($child_pid && !$this -> get_child($_, $err)) $this -> _failure(sprintf('Process [%s] child PID failure: %s (%s)', $pid, $err, $command));
		$this -> _state = 'open';
		return true;
	}

	/**
	 * get process child PID
	 * 
	 * @param  array	$pids	- ByRef descendant PIDs
	 * @param  string	$error	- ByRef error message
	 * @return int|false		- child PID or false on failure
	 */
	public function get_child(&$pids=null, &$error=null){
		$error = null;
		if (!($cpid = static::child($pid = $this -> _pid, $pids, $err))){
			$this -> status($_, $running);
			if ($running){
				$error = $err;
				return false;
			}
		}
		$pid = $cpid ? $cpid : $pid;
		if ($this -> _state === 'opening'){
			$this -> _pids = array_merge($this -> _pids, $pids);
			$this -> _pid = $pid;
		}
		return $pid;
	}

	/**
	 * get running PID
	 * 
	 * @return int|null  - PID or null if not found
	 */
	public function running(){
		$running_pid = null;
		$pid = null;
		if (is_resource($this -> _process)){
			$this -> status($pid, $running);
			if ($running) $running_pid = $pid;
		}
		if (!$running_pid && is_array($pids = $this -> _pids) && count($pids)){
			foreach ($pids as $_pid){
				if ($_pid === $pid) continue;
				if (static::exists($_pid)){
					$running_pid = $_pid;
					break;
				}
			}
		}
		return $running_pid;
	}

	/**
	 * get pipe resource
	 * 
	 * @param  int  $index	- pipe index (0 = stdin, 1 = stdout, 2 = stderr) [default=1].
	 * @return resource|null
	 */
	public function pipe($index=1){
		if (is_array($this -> _pipes) && isset($this -> _pipes[$index]) && is_resource($pipe = &$this -> _pipes[$index])) return $pipe;
	}

	/**
	 * close pipe resource
	 * 
	 * @param  int  $index	- pipe index (0 = stdin, 1 = stdout, 2 = stderr)
	 * @return bool			- success
	 */
	public function close_pipe($index){
		$result = true;
		if ($pipe = $this -> pipe($index)) $result = fclose($pipe);
		return $result;
	}

	/**
	 * process read output
	 * 
	 * @param  bool		$print				- buffer print
	 * @param  array	$buffer_callback	- buffer callback [return false to abort read] (i.e. function(string $buffer){...})
	 * @param  resource	$resource			- resource pipe/path [default: $this -> pipe(1)]
	 * @param  string	$error				- ByRef error message
	 * @param  int		$abort				- ByRef abort status (0=no abort, 1=callback abort, 2=connection abort)
	 * @return string|false					- read contents or false on error
	 */
	public function output($print=false, $buffer_callback=null, $resource=null, &$error=null, &$abort=null){
		$error = null;
		$abort = null;
		if (is_string($resource) && ($path = trim($resource))) return static::read_file($path, $this -> running(), $_seek=0, $print, $buffer_callback, $error, $abort);
		else if (is_resource($resource)) return static::read_pipe($resource, $print, $buffer_callback, $error, $abort);
		return static::read_pipe($this -> pipe(1), $print, $buffer_callback, $error, $abort);
	}

	/**
	 * is windows platform
	 * 
	 * @param  string  $uname - ByRef php_uname result
	 * @return bool
	 */
	public static function is_win(&$uname=null){
		static $_is_win, $_uname;
		if (!is_bool($_is_win)) $_is_win = stripos($_uname = php_uname('s'), 'win') > -1;
		$uname = $_uname;
		return $_is_win;
	}

	/**
	 * check if process is running on console.
	 * 
	 * @return int  - mode (0=not console, 1=non-interactive, 2=interactive)
	 */
	public static function is_console(){
		static $value;
		if (!is_integer($value)) $value = in_array(strtolower(php_sapi_name()), ['cli', 'phpdbg']) ? (defined('STDIN') && stream_isatty(STDIN) ? 2 : 1) : 0;
		return $value;
	}

	/**
	 * parse process options
	 * 
	 * - result (see const OPTIONS)
	 * 
	 * @param  array	$options	- process options
	 * @param  bool		$as_win		- parse options for windows platform [default: static::is_win()]
	 * @param  string	$error		- ByRef error message
	 * @return array|false			- options array or false on error
	 */
	public static function options($options=null, $as_win=null, &$error=null){
		$error = null;
		try {
			
			//vars
			$opts = self::OPTIONS;
			$options = is_array($options) ? $options : [];
			$as_win = is_null($as_win) ? static::is_win() : !!$as_win;
			
			//helper method - check if value is an associative array
			$_is_assoc = function($val){
				return is_array($val) && ($c = count($val)) && array_keys($val) !== range(0, $c - 1);
			};
			
			//options - descriptor_spec
			$descriptor_spec = self::DESCRIPTOR_SPEC;
			if (array_key_exists($key = 'descriptor_spec', $options)){
				$descriptor_spec = [];
				if (!empty($val = $options[$key])){
					if (!is_array($val)) throw new Exception(sprintf('Options descriptor_spec value is not an array. ([%s] %s)', gettype($val), json_encode($val)));
					foreach ($val as $i => $v){
						if (!(is_integer($i) && $i >= 0)) throw new Exception(sprintf('Options descriptor_spec entry key is not a valid integer. ([%s] %s)', gettype($i), $i));
						if (is_array($v)) $descriptor_spec[$i] = $v;
						elseif (!empty($v)) throw new Exception(sprintf('Options descriptor_spec entry value is invalid. (%s => [%s] %s)', $i, gettype($v), json_encode($v)));
					}
				}
			}
			$opts[$key] = $descriptor_spec;
	
			//options - cwd
			$cwd = null;
			if (array_key_exists($key = 'cwd', $options)){
				if (!empty($val = $options[$key])){
					if (($path = realpath(trim($val))) === false) throw new Exception(sprintf('Options cwd value is not a real path. ([%s] %s)', gettype($val), $val));
					if (!is_dir($path)) throw new Exception(sprintf('Options cwd path value is not a directory. (%s)', $path));
					$cwd = $path;
				}
			}
			$opts[$key] = $cwd;

			//options - env_vars
			$env_vars = [];
			if (array_key_exists($key = 'env_vars', $options)){
				if (!empty($val = $options[$key])){
					if (!$_is_assoc($val)) throw new Exception(sprintf('Options env_vars value is not an associative array. ([%s] %s)', gettype($val), json_encode($val)));
					foreach ($val as $i => $v){
						if (!empty($v)) $env_vars[$i] = $v;
					}
				}
			}
			$opts[$key] = !empty($env_vars) ? $env_vars : null;

			//options - other_options
			$other_options = $as_win ? self::WIN_OPTIONS : [];
			if (array_key_exists($key = 'other_options', $options)){
				$other_options = [];
				if (!empty($val = $options[$key])){
					if (!$_is_assoc($val)) throw new Exception(sprintf('Options other_options value is not an associative array. ([%s] %s)', gettype($val), json_encode($val)));
					foreach ($val as $i => $v){
						if (!empty($v)) $other_options[$i] = $v;
					}
				}
			}
			$opts[$key] = !empty($other_options) ? $other_options : null;

			//result
			return $opts;
		}
		catch (Exception $e){
			$error = $e -> getMessage();
			return false;
		}
	}

	/**
	 * parse command line string
	 * 
	 * - result [
	 *    'cmd' => null,			//(string) normalized command line string
	 *    'cmd_bg' => null,			//(string) background command line string
	 *    'stdout' => null,			//(string) parsed command stdout (i.e. '> output.log')
	 *    'stdout_path' => null,	//(string) parsed command stdout path (i.e. 'output.log')
	 *    'stderr' => null,			//(string) parsed command stderr (i.e. '> error.log')
	 *    'stderr_path' => null,	//(string) parsed command stderr path (i.e. 'error.log')
	 *    'stderr_merge' => 0,		//(int/bool) whether command has 2>&1
	 * ];
	 * 
	 * - 'cmd_bg' format - windows platform: "start /b [COMMAND] >nul 2>&1 &"
	 * - 'cmd_bg' format - other platform (linux/unix): "[COMMAND] >/dev/null 2>&1 & echo &!"
	 * 
	 * @param  string	$cmd	- command line string
	 * @param  bool		$as_win	- parse command for windows platform [default: static::is_win()]
	 * @param  string	$error	- ByRef error message
	 * @return array			- parsed command data or false on error
	 */
	public static function parse($cmd, $as_win=null, &$error=null){
		static $_get_output, $_quote_restore;
		$error = null;

		//check command - replace unusual whitespace
		if (!(is_string($cmd) && ($tmp = trim(str_replace(urldecode('%C2%A0'), ' ', $cmd))))){
			if (is_string($cmd) || is_null($cmd)) $error = 'Empty command line string.';
			else $error = sprintf('Invalid command line string. ([%s] %s)', gettype($cmd), json_encode($cmd));
			return false;
		}
		else $cmd = $tmp;
		
		//vars
		$as_win = is_null($as_win) ? static::is_win() : !!$as_win;
		$stdout_path = $stderr_path = $stdout = $stderr = $tmp = $stderr_merge = null;
		$s = $cmd;
		
		//backup quotes
		$q = -1;
		$quote = [];
		if (strpos($s, '\'') !== false || strpos($s, '"') !== false){
			
			//quote - "
			$s = preg_replace_callback('/\'([^\']+)\'/', function($match) use (&$quote, &$q){
				$q ++;
				$quote[$tmp = '__' . $q . '__'] = $match[0];
				return $tmp;
			}, $s);

			//quote - '
			$s = preg_replace_callback('/"([^"]+)"/', function($match) use (&$quote, &$q){
				$q ++;
				$quote[$tmp = '__' . $q . '__'] = $match[0];
				return $tmp;
			}, $s);

			//helper method - quote restore
			if (!$_quote_restore) $_quote_restore = function($str, $q, $quote){
				$i = $key = null;
				for ($i = $q; $i >= 0; $i --){
					$key = '__' . $i . '__';
					$str = str_replace($key, $quote[$key], $str);
				}
				unset($i, $key);
				return $str;
			};
		}

		//parse command pipe
		if (strpos($s, '>') !== false){
			$stdout_append = 0;
			$stderr_append = 0;

			//check stdout
			if (preg_match('/(1| )\>\>/', $s)) $stdout_append = 1;
			
			//check stderr
			if (preg_match('/2\>\>/', $s)) $stderr_append = 1;
			
			//normalize stdout/stderr
			$s = preg_replace('/\>+/', '>', $s);
			$s = preg_replace('/([^\>]+\=[12])\>/', '$1 >', $s);
			$s = preg_replace('/([^12]+)\>/', '$1-1>', $s, 1);
			$s = preg_replace('/([^12]+)\>/', '$1-2>', $s, 1);
			$s = preg_replace('/-([12])\>/', '$1>', $s, 1);
			$s = preg_replace('/&([12])\>/', '$1>', $s);
			$s = preg_replace('/([^\>]+)([12])\>/', '$1 $2>', $s);

			//trim extra whitespace
			$s = preg_replace('/[ ]+/', ' ', $s);
			$s = preg_replace('/\s*&([12])/', '&$1', $s);

			//has 2>&1 (merge stderr & stdout)
			if (strpos($s, '2>&1') !== false){
				$stderr_merge = 1;
				$s = trim(str_replace('2>&1', '', $s));
			}

			//helper method - get stdout/stderr path
			if (!$_get_output) $_get_output = function($_cmd, $_as_win, $_stderr_path=0){
				$a = $_stderr_path ? 2 : 1;
				$b = $_stderr_path ? 1 : 2;
				$p = $x = $d = $v = null;
				if (!(($p = strpos($_cmd, "$a>")) !== false && ($p += 2))) return;
				if (($p = strpos($_cmd, "$a>")) !== false && ($p += 2)){
					$x = ($x = strpos($_cmd, "$b>", $p)) !== false ? $x : (($x = strpos($_cmd, '>', $p)) !== false ? $x : -1);
					$v = ($d = $x < 0 ? 0 : $x - $p) ? substr($_cmd, $p, $d) : substr($_cmd, $p);
					if (!strlen($v = trim($v))) $v = null;
					elseif (!preg_match(sprintf('/^[^%s]*$/', preg_quote('*?"<>|:&', '/')), $v)) $v = null;
					elseif (in_array(strtolower($v), ['nul', 'null', '/dev/null'])) $v = $_as_win ? 'nul' : '/dev/null';
				}
				unset($a, $b, $p, $x, $d);
				return $v;
			};

			//set stdout/stderr
			$stdout_path = ($tmp = $_get_output($s, $as_win)) ? $tmp : null;
			$stderr_path = ($tmp = $_get_output($s, $as_win, 1)) ? $tmp : null;
			$stdout = $stdout_path ? ($stdout_append ? '>>' : '>') . $stdout_path : null;
			$stderr = $stderr_path ? '2' . ($stderr_append ? '>>' : '>') . $stderr_path : null;
			unset($stdout_append, $stderr_append);

			//remove stdout/stderr from command line
			$s = preg_match('/^(.+?(?=[0-9]*\>))/', $s, $matches) && count($matches) ? trim($matches[0]) : trim($s);
		}

		//restore quotes
		if ($q > -1 && !empty($quote) && $_quote_restore){
			$s = $_quote_restore($s, $q, $quote);
			if ($stdout) $stdout = $_quote_restore($stdout, $q, $quote);
			if ($stderr) $stderr = $_quote_restore($stderr, $q, $quote);
		}

		//set normalized/background command
		$bg = $s;
		if ($stdout){
			$s .= ($tmp = ' ' . $stdout);
			$bg .= $tmp;
		}
		else $bg .= ' >' . ($as_win ? 'nul' : '/dev/null');
		if ($stderr){
			$s .= ($tmp = ' ' . $stderr);
			$bg .= $tmp;
		}
		else {
			$s .= $stderr_merge ? ' 2>&1' : '';
			$bg .= ' 2>' . ($stderr_merge ? '&1' : ($as_win ? 'nul' : '/dev/null'));
		}

		//background command - platform format
		if ($as_win){
			if (preg_match($tmp = '/^(start\s*(\/b)?)((?![a-z]).+)$/i', $bg)) $bg = trim(preg_replace('/\s+/', ' ', preg_replace($tmp, '$3', $bg)));
			$bg = 'start /b ' . $bg . ' &';
		}
		else $bg .= ' & echo $!';
		unset($tmp, $q, $quote);
		
		//result
		return [
			'cmd' => $s,
			'cmd_bg' => $bg,
			'stdout' => $stdout,
			'stdout_path' => $stdout_path,
			'stderr' => $stderr,
			'stderr_path' => $stderr_path,
			'stderr_merge' => $stderr_merge ? 1 : 0,
		];
	}

	/**
	 * get process config
	 * 
	 * result [
	 * 		'cmd' => null,				- (string) normalized command line
	 * 		'command' => null,			- (string) proc_open command line
	 * 		'stdout_path' => null,		- (string) parsed command line stdout path
	 * 		'stderr_path' => null,		- (string) parsed command line stderr path
	 * 		'background' => false,		- (bool) command runs in the background
	 * 		'as_win' => null,			- (bool) parsed for windows platform
	 * 		'descriptor_spec' => [],	- (array) options - proc_open file descriptors
	 * 		'cwd' => null,				- (string) options - proc_open working directory
	 * 		'env_vars' => null,			- (array) options - proc_open env_vars
	 * 		'other_options' => null,	- (array) options - proc_open other options
	 * ]
	 * 
	 * @param  string	$cmd		- command line string
	 * @param  array	$options	- process options (proc_open args)
	 * @param  bool		$background	- process runs in the background
	 * @param  bool		$as_win		- parse for windows platform [default: static::is_win()]
	 * @param  string	$error		- ByRef error message
	 * @return array|false			- config data or false on error.
	 */
	public static function config($cmd, $options=null, $background=false, $as_win=null, &$error=null){
		$error = null;

		//parse
		$as_win = is_null($as_win) ? static::is_win() : !!$as_win;
		if (!($parsed = static::parse($cmd, $as_win, $error))) return false;
		if (!($options = static::options($options, $error))) return false;

		//config
		$command = $cmd = $parsed['cmd'];
		$descriptor_spec = $options['descriptor_spec'];
		if ($background = !!$background){
			$command = $parsed['cmd_bg'];
			if ($as_win && count($descriptor_spec)) $descriptor_spec = array_slice($descriptor_spec, 0, 1); //only stdin (windows)
		}

		//result
		return [
			'cmd' => $cmd,
			'command' => $command,
			'stdout_path' => $parsed['stdout_path'],
			'stderr_path' => $parsed['stderr_path'],
			'background' => $background,
			'as_win' => $as_win,
			'descriptor_spec' => $descriptor_spec,
			'cwd' => $options['cwd'],
			'env_vars' => $options['env_vars'],
			'other_options' => $options['other_options'],
		];
	}

	/**
	 * PID validated integer
	 * 
	 * @param  int		$value	- validate PID value
	 * @param  string	$error	- ByRef error message
	 * @return int|false		- PID integer or false on failure
	 */
	public static function pid($value, &$error=null){
		$error = null;
		if (is_numeric($pid = trim($value)) && ($pid = (int) $pid) > 0) return $pid;
		$error = sprintf('Invalid PID value. ([%s] %s)', gettype($value), json_encode($value));
		return false;
	}
	
	/**
	 * pid process child
	 * 
	 * @param  int		$pid	- PID (parent)
	 * @param  array	$pids	- ByRef descendant PIDs
	 * @param  string	$error	- ByRef error message
	 * @return int|false		- child PID or false on failure
	 */
	public static function child($pid, &$pids=null, &$error=null){
		$pids = [];
		$error = null;

		//check pid
		if (!($pid = static::pid($pid, $error))) return false;

		//command line
		$is_win = static::is_win();
		if ($is_win) $cmd = sprintf('wmic process get parentprocessid,processid | findstr /i "%s"', $pid);
		else $cmd = sprintf('ps afx --ppid %s', $pid);

		//run command
		if (($out = static::run($cmd, $err)) === false){
			$error = "Pid [$pid] process child exec failure: $err";
			return false;
		}

		//parse output pids
		$parsed = [];
		if ($out = trim($out)){
			$parsed = explode($is_win ? ' ' : "\n", $out);
			$parsed = array_map(function($val) use (&$is_win, &$cmd){
				if (!$is_win){
					if (strpos($val, $cmd) !== false) return null;
					if (!preg_match('/^\s*([0-9]+)\s*/', $val, $val)) return null;
					$val = $val[1];
				}
				else $val = trim($val);
				return $val && is_numeric($val) && ($val = (int) $val) > 0 ? $val : null;
			}, $parsed);
			$parsed = empty($parsed) ? [] : array_filter($parsed, function($val){
				return is_numeric($val) && trim((int) $val) === trim($val);
			});
			$parsed = empty($parsed) ? [] : array_values($parsed);
			if (!empty($parsed)){
			    if (in_array($pid, $parsed)){
			       $seen = 0;
			       $pids = array_filter($parsed, function($val) use (&$pid, &$seen){
    					if ($val === $pid){
    						$seen = 1;
    						return false;
    					}
					    return $seen;
				    });
			    }
				else $pids = $parsed;
				$pids = empty($pids) ? [] : array_values($pids);
			}
		}

		//result
		$result = ($len = count($pids)) ? $pids[$len - 1] : false;
		if (!$result) $error = "Pid [$pid] process child not found.";
		return $result;
	}

	/**
	 * pid process exists
	 * 
	 * @param  int		$pid	- PID
	 * @param  string	$error	- ByRef error message
	 * @return int|false		- running PID | 0 nonexistent | false on error
	 */
	public static function exists($pid, &$error=null){
		$error = null;

		//check pid
		if (!($pid = static::pid($pid, $error))) return false;

		//command line
		if ($is_win = static::is_win()) $cmd = sprintf('tasklist /FI "PID eq %d" 2>&1', $pid);
		else $cmd = sprintf('ps -p %d -opid=,cmd= 2>&1', $pid);

		//run command
		if (($out = static::run($cmd, $err)) === false){
			$error = "Pid [$pid] process exists exec failure: $err";
			return false;
		}

		//result
		$result = ($out = trim($out)) && strpos($out, "$pid") !== false ? $pid : 0;
		return $result;
	}

	/**
	 * pid process kill
	 * 
	 * @param  int		$pid	- PID
	 * @param  string	$error	- ByRef error message
	 * @return int|false		- status (-1 = nonexistent, 1 = killed) or false on error
	 */
	public static function kill($pid, &$error=null){
		$error = null;

		//check pid
		if (!($pid = static::pid($pid, $error))) return false;

		//command line
		if ($is_win = static::is_win()) $cmd = sprintf('taskkill /F /T /PID %s 2>&1', $pid);
		else $cmd = sprintf('kill -s 9 %s 2>&1', $pid);

		//run command
		if (($out = static::run($cmd, $err)) === false){
			$error = "Pid [$pid] process kill exec failure: $err";
			return false;
		}

		//parse output - killed status
		$status = null;
		if ($out = trim($out)){
			$status = 1;
			if ($is_win){
				if (stripos($out, 'no tasks') !== false || stripos($out, 'not found') !== false) $status = -1;
			}
			else if (stripos($out, 'no such process') !== false) $status = -1;
		}

		//verify dead
		if (!$status){
			if (static::exists($pid)){
				$error = "Pid [$pid] process kill failed. (still running)";
				return false;
			}
			else $status = -1;
		}

		//result
		return $status;
	}

	/**
	 * Timedout helper.
	 * 
	 * @param  float  $timeout  - Timeout seconds.
	 * @param  float  $start    - Start time seconds (microtime(1)).
	 * @param  float  $elapsed  - Seconds elapsed (microtime(1) - $start).
	 * @return bool
	 */
	public static function timedout($timeout=null, $start=null, &$elapsed=null){
		$timeout = is_numeric($timeout) && ($timeout = (float) $timeout) >= 0 ? $timeout : 0;
		$start = is_numeric($start) ? (float) $start : 0;
		$elapsed = microtime(1) - $start;
		return $elapsed >= $timeout;
	}

	/**
	 * Search for executable file.
	 * 
	 * - REF: https://github.com/symfony/process/blob/6.1/ExecutableFinder.php
	 * 
	 * @param  string		$name		- The executable name (without the extension) [Throws exception if undefined]
	 * @param  string|null	$default	- The default to return if no executable is found
	 * @param  array		$extraDirs	- Additional dirs to check into
	 * @return mixed					- (string executable file path | $default value)
	 */
	public static function find_exe($name, $default=null, $extraDirs=[]){
		static $suffixes;
		$dirs = [];
		$ps = PATH_SEPARATOR;
		if (!($name = trim($name))) throw new Exception('Undefined find_exe name.');
		if ($tmp = ini_get('open_basedir')){
			$searchPath = array_merge(explode($ps, $tmp), $extraDirs);
			foreach ($searchPath as $path){
				if (@is_dir($path)) $dirs[] = $path;
				elseif (strtolower(basename($path)) === strtolower($name) && @is_executable($path)) return $path;
			}
		}
		else $dirs = array_merge(explode($ps, getenv('PATH') ?: getenv('Path')), $extraDirs);
		$ds = DIRECTORY_SEPARATOR;
		if (!$suffixes){
			$suffixes = [''];
			if ('\\' === $ds){
				$pathExt = getenv('PATHEXT');
				$suffixes = array_merge($pathExt ? explode($ps, $pathExt) : self::EXE_SUFFIXES, $suffixes);
			}
		}
		foreach ($suffixes as $suffix){
			foreach ($dirs as $dir){
				if (@is_file($file = $dir.$ds.$name.strtolower($suffix)) && ('\\' === $ds || @is_executable($file))) return $file;
			}
		}
		return $default;
	}

	/**
	 * Find php executable binary file path
	 * 
	 * - REF: https://github.com/symfony/process/blob/6.1/PhpExecutableFinder.php
	 * - set custom php executable path globally: $GLOBALS['__PHP_EXE__']
	 * - prefers linux/unix default php executable path if available: /usr/local/bin/php
	 * 
	 * @param  bool		$includeArgs	- include args (\PHP_BINARY - 'phpdbg' === PHP_SAPI)
	 * @return string|false				- string php executable file path or false on error
	 */
	public static function find_php($includeArgs=false){
		static $cache;

		//cached
		$cache_key = $includeArgs ? 'php_args' : 'php';
		if (is_array($cache) && isset($cache[$cache_key])) return $cache[$cache_key];
		$_cache = function($php) use (&$cache, &$cache_key, &$includeArgs){
			if (!@is_executable($php) || @is_dir($php)) return false;
			if (!is_array($cache)) $cache = [];
			return $cache[$cache_key] = $php;
		};

		//check global
		if (isset($GLOBALS['__PHP_EXE__']) && is_executable($php = $GLOBALS['__PHP_EXE__'])) return $_cache($php);
		
		//check (linux/unix) default
		if (!static::is_win() && is_executable($php = '/usr/local/bin/php')) return $_cache($php);
		
		//check env PHP_BINARY
		$ds = DIRECTORY_SEPARATOR;
		if ($php = getenv('PHP_BINARY')){
			if (!is_executable($php)){
				$command = '\\' === $ds ? 'where' : 'command -v';
				$command .= ' ' . escapeshellarg($php);
				$out = trim(static::run($command));
				if ($php = strtok($out, PHP_EOL)){
					if (!is_executable($php)) return false;
				}
				else return false;
			}
			return $_cache($php);
		}

		//check (args) \PHP_BINARY
		$args = [];
		if ('phpdbg' === PHP_SAPI) $args[] = '-qrr';
		$args = $includeArgs && $args ? ' ' . implode(' ', $args) : '';
		if (($tmp = PHP_BINARY) && in_array(PHP_SAPI, ['cgi-fcgi', 'cli', 'cli-server', 'phpdbg'], true)) return $_cache($tmp . $args);
		
		//check env PHP_PATH
		if ($php = getenv('PHP_PATH')) return $_cache($php);
		
		//check env PHP_PEAR_PHP_BIN
		if (($php = getenv('PHP_PEAR_PHP_BIN')) && @is_executable($php) && !@is_dir($php)) return $_cache($php);
		
		//check in PHP_BINDIR (/usr/bin)
		$bin_dir = PHP_BINDIR;
		if (@is_executable($php = $bin_dir . ('\\' === $ds ? '\\php.exe' : '/php')) && !@is_dir($php)) return $_cache($php);
		
		//check in common folders
		$dirs = [$bin_dir];
		if ('\\' === $ds) $dirs[] = 'C:\xampp\php\\';
		return $_cache(static::find_exe('php', false, $dirs));
	}
	
	/**
	 * Poll callback helper.
	 * 
	 * @param  callable $poll_callback	- Polling callback (this should return truthy value to abort polling)
	 * @param  int		$sleep_ms		- Polling interval sleep microseconds [default 1000 (1 sec)] (minimum 100)
	 * @param  int		$timeout		- Polling timeout seconds. [default 10 sec] (0 = unlimited)
	 * @param  string	$error			- ByRef Polling error message
	 * @return bool						- Polling complete (false on error)
	 */
	public static function poll($poll_callback=null, $sleep_ms=1000, $timeout=10, &$error=null){
		$error = null;
		try {
			if (!is_callable($poll_callback)) throw new Exception('Polling callback is not callable.');
			$sleep_ms = is_integer($sleep_ms) && $sleep_ms >= 100 ? $sleep_ms : 1000;
			$timeout = is_integer($timeout) && $timeout >= 0 ? $timeout : 10;
			$start = microtime(1);
			while (true){
				if (call_user_func($poll_callback)) return true;
				if ($timeout && static::timedout($timeout, $start, $eta)) throw new Exception('Polling timed out.');
				usleep($sleep_ms * 1000);
			}
		}
		catch (Exception $e){
			$error = $e -> getMessage();
			return false;
		}
	}

	/**
	 * Poll process exists status.
	 * 
	 * @param  int		$pid			- Process PID
	 * @param  bool		$exists			- Poll check if PID process is running if enabled otherwise checks not running
	 * @param  callable $poll_callback	- Poll callback method called after failed check (aborts polling if callback returns truthy value)
	 * @param  int		$sleep_ms		- Polling interval sleep microseconds [default 1000 (1 sec)] (minimum 100)
	 * @param  int		$timeout		- Polling timeout seconds. [default 10 sec] (0 = unlimited)
	 * @param  string	$error			- ByRef Polling error message
	 * @return bool						- Polling complete (false on error)
	 */
	public static function poll_exists($pid, $exists=true, $poll_callback=null, $sleep_ms=1000, $timeout=10, &$error=null){
		$error = null;
		if (!($pid = static::pid($pid, $error))) return false;
		$poll_callback = is_callable($poll_callback) ? $poll_callback : null;
		return static::poll(function() use (&$pid, &$exists, &$poll_callback){
			if (!!static::exists($pid) === !!$exists) return true;
			if ($poll_callback && call_user_func($poll_callback)) return true;
		}, $sleep_ms, $timeout, $error);
	}

	/**
	 * set no execution limit
	 * 
	 * ~ usage: $_restore = static::no_limit();
	 * ~ restore: $_restore();
	 * 
	 * @param  int	$ignore_abort	- ByRef previous value ignore_user_abort()
	 * @param  int	$max_time		- ByRef previous value max_execution_time
	 * @return Closure  - call to restore previous values
	 */
	public static function no_limit(&$ignore_abort=null, &$max_time=null){
		$ignore_abort = (int) ignore_user_abort();
		$max_time = (int) ini_get('max_execution_time');
		set_time_limit(0);
		ignore_user_abort(1);
		return function() use (&$ignore_abort, &$max_time){
			ignore_user_abort($ignore_abort);
			set_time_limit($max_time);
		};
	}

	/**
	 * output buffer end
	 * 
	 * @param  bool  $clean	- use method - ob_end_clean() if enabled [default: ob_end_flush()]
	 * @return bool			- method success
	 */
	public static function print_end($clean=false){
		$res = true;
		while (ob_get_level() && ($res = $clean ? ob_end_clean() : ob_end_flush()));
		return $res;
	}

	/**
	 * output buffer restart (end previous buffer if any - ob_start())
	 * 
	 * @param  bool  $clean	- ob_end_clean() if enabled [default: ob_end_flush()]
	 * @return bool			- ob_start() success
	 */
	public static function print_start($clean=false){
		static::print_end($clean);
		$res = true;
		if (!ob_get_level()) $res = ob_start();
		return $res;
	}

	/**
	 * print output
	 * 
	 * @param  string	$value	- print value.
	 * @param  bool		$br		- enable line break.
	 * @param  string	$str	- ByRef stringified print value (without buffer padding or line break)
	 * @return string			- output buffer
	 */
	public static function print_out($value, $br=true, &$str=null){
		
		//to string
		if (is_null($value) || is_bool($value) || is_object($value)) $value = json_encode($value);
		elseif (is_array($value)){
			$_arr_val = function($arr) use (&$_arr_val){
				$tmp = [];
				foreach ($arr as $key => $val){
					if (is_null($val) || is_bool($val) || is_object($val)) $val = json_encode($val);
					elseif (is_array($val)) $val = $_arr_val($val);
					$tmp[$key] = $val;
				}
				return $tmp;
			};
			$value = print_r($_arr_val($value), 1);
		}
		
		//string pad, break
		$str = $value;
		$reg = '/\r?\n[\t ]*$/s';
		$reg_match = preg_match($reg, $value, $matches);
		$pad_str = !static::is_win();
		if ($pad_str){
			$pad_size = 4096;
			$append = '';
			if ($reg_match){
				$pad_size -= strlen($append = $matches[0]);
				$value = preg_replace($reg, '', $value);
			}
			$value = str_pad($value, $pad_size, ' ', STR_PAD_RIGHT) . $append;
		}
		if ($br && !$reg_match) $value .= "\n";

		//print
		echo $value;
		ob_flush();
		flush();

		//result - buffer
		return $value;
	}

	/**
	 * read pipe resource buffer
	 * 
	 * @param  resource	$pipe				- resource pipe
	 * @param  bool		$print				- buffer print
	 * @param  array	$buffer_callback	- buffer callback [return false to abort read] (i.e. function(string $buffer){...})
	 * @param  string	$error				- ByRef error message
	 * @param  int		$abort				- ByRef abort status (0=no abort, 1=callback abort, 2=connection abort)
	 * @return string|false					- read contents or false on error
	 */
	public static function read_pipe($pipe, $print=false, $buffer_callback=null, &$error=null, &$abort=null){
		$error = null;
		$abort = 0;

		//check pipe
		if (!is_resource($pipe)){
			$error = 'Pipe resource is invalid.';
			return false;
		}

		//init
		$output = '';
		$read_size = 4096;
		$buffer_callback = is_callable($buffer_callback) ? $buffer_callback : null;
		$_restore = static::no_limit($ignore_abort);
		if ($print) static::print_start();
		
		//read loop
		while (!feof($pipe)){
			
			//read
			$buffer = fgets($pipe, $read_size);

			//buffer
			if (strlen($buffer)){
				
				//print
				if ($print) static::print_out($buffer, $_br=false, $buffer);
				
				//output
				$output .= $buffer;
				
				//callback
				if ($buffer_callback){
					try {
						if (call_user_func_array($buffer_callback, [$buffer]) === false){
							$abort = 1;
							break;
						}
					}
					catch (Exception $e){
						$_restore();
						$error = 'Read pipe callback failure: ' . $e -> getMessage();
						return false;
					}
				}

				//abort
				if (connection_aborted() && !$ignore_abort){
					$abort = 2;
					break;
				}
			}
		}

		//done - result
		$_restore();
		return $output;
	}

	/**
	 * read file resource buffer
	 * 
	 * @param  string	$path				- file path string
	 * @param  int		$pid				- related process Id (on read failure (eof), waits and retries read while process is still running)
	 * @param  int		$seek				- file read initial seek position [default=0]
	 * @param  bool		$print				- buffer print
	 * @param  array	$buffer_callback	- buffer callback [return false to abort read] (i.e. function(string $buffer){...})
	 * @param  string	$error				- ByRef error message
	 * @param  int		$abort				- ByRef abort status (0=no abort, 1=callback abort, 2=connection abort)
	 * @return string|false					- read contents or false on error
	 */
	public static function read_file($path, $pid=null, $seek=0, $print=false, $buffer_callback=null, &$error=null, &$abort=null){
		$error = null;
		$abort = 0;
		
		//check path
		if (!is_file($path)){
			$error = "File resource does not exist. ($path)";
			return false;
		}

		//init
		$output = '';
		$read_size = 4096;
		$buffer_callback = is_callable($buffer_callback) ? $buffer_callback : null;
		$pid = is_numeric($pid) && ($pid = (int) $pid) >= 1 ? $pid : null;
		$seek = is_numeric($seek) && ($seek = (int) $seek) >= 0 ? $seek : 0;
		$_restore = static::no_limit($ignore_abort);
		if ($print) static::print_start();

		//try loop
		$stop = 0;
		$exists = 1;
		while (1){

			//open
			if (!is_file($path)) break;
			$pipe = @fopen($path, 'rb');
			if (!is_resource($pipe)) break;

			//stop reset
			if ($stop){
				if (($stat = fstat($pipe)) === false){
					$_restore();
					$error = "File resource fstat failure. ($path)";
					return false;
				}
				if ($stat['size'] > $seek) $stop = 1;
			}

			//seek
			if (fseek($pipe, $seek) < 0){
				$_restore();
				$error = "File resource fseek [$seek] failure. ($path)";
				return false;
			}

			//read loop
			while (!feof($pipe)){
				
				//read
				$buffer = fread($pipe, $read_size);

				//update seek
				if (($seek = ftell($pipe)) === false){
					$_restore();
					$error = "File resource ftell failure. ($path)";
					return false;
				}

				//buffer
				if (strlen($buffer)){

					//print
					if ($print) static::print_out($buffer, $_br=false, $buffer);

					//output
					$output .= $buffer;

					//callback
					if ($buffer_callback){
						try {
							if (call_user_func_array($buffer_callback, [$buffer]) === false){
								$abort = 1;
								break;
							}
						}
						catch (Exception $e){
							$_restore();
							$error = 'Read file callback failure: ' . $e -> getMessage();
							return false;
						}
					}

					//abort
					if (connection_aborted() && !$ignore_abort){
						$abort = 2;
						break;
					}
				}
			}

			//close
			fclose($pipe);

			//check stop/retry
			if (!$abort && $pid){
				if (!$stop) $exists = static::exists($pid);
				if (!$exists){
					$stop ++;
					if ($stop < 3){
						if ($stop > 1) usleep(500 * 1000);
						continue;
					}
				}
				else continue;
			}

			//break
			break;
		}

		//done
		$_restore();

		//result
		return $output;
	}

	/**
	 * open process get output
	 * 
	 * @param  string	$cmd				- command line string
	 * @param  string	$error				- ByRef error message
	 * @param  Process	$process			- ByRef process instance
	 * @param  array	$options			- process options (see static::options())
	 * @param  bool		$print				- buffer print
	 * @param  array	$buffer_callback	- buffer callback [return false to abort read] (i.e. function(string $buffer){...})
	 * @param  resource	$resource			- buffer read resource pipe/path [default: $proc -> pipe(1)]
	 * @param  int		$abort				- ByRef buffer abort status (0=no abort, 1=callback abort, 2=connection abort)
	 * @return string|false					- buffer output string or false on error
	 */
	public static function run($cmd, &$error=null, &$process=null, $options=null, $print=false, $buffer_callback=null, $resource=null, &$abort=null){
		$abort = null;
		$error = null;
		$process = new static($cmd, $options, $_background=false);
		if (!$process -> open()){
			$error = $process -> error;
			return false;
		}
		$process -> close_pipe(0);
		if (($output = $process -> output($print, $buffer_callback, $resource, $error, $abort)) === false) return false;
		$process -> close();
		return $output;
	}

	/**
	 * open background process (cached)
	 * 
	 * @param  string	$cmd			- command line (constructor argument 1)
	 * @param  string	$error			- ByRef failure error message
	 * @param  array	$options		- process options (see static::options())
	 * @param  string	$pid_file		- Background process PID cache file path
	 * @param  bool		$resume			- Enable background process resume if cached PID is still running (use 0 to kill existing)
	 * @param  int		$resumed		- ByRef resumed status (1 = process was resumed, 0 = new process, null = failure)
	 * @return int|false				- child PID or false on error
	 */
	public static function run_bg($cmd, &$error=null, $options=null, $pid_file=null, $resume=true, &$resumed=null){
		$error = null;
		$resumed = null;
		$pid_file = is_string($pid_file) && ($pid_file = trim($pid_file)) ? $pid_file : null;
		if (is_file($pid_file) && ($pid = static::pid(file_get_contents($pid_file)))){
			if (static::exists($pid)){
				if ($resume){
					$resumed = 1;
					return $pid;
				}
				elseif ($resume === 0) static::kill($pid);
			}
		}
		$process = new static($cmd, $options, true);
		if (!$process -> open()){
			$error = $process -> error;
			return false;
		}
		$process -> close();
		$pid = $process -> pid;
		if ($pid_file && !file_put_contents($pid_file, "$pid")){
			$error = "Process [$pid] cache PID write failure! ($pid_file)";
			$process -> close(1);
			return false;
		}
		$resumed = 0;
		return $pid;
	}
}

#================================  !_funcs   =================================

//get option
function _option($key=null, $value='!undefined'){
	if (!(isset($GLOBALS['__options__']) && is_array($GLOBALS['__options__']))) return _failure('Undefined $GLOBALS[__options__] array.');
	if (empty($key)) return $value === '!undefined' ? $GLOBALS['__options__'] : _failure('Undefined $GLOBALS[__options__] key.');
	if ($value !== '!undefined') $GLOBALS['__options__'][$key] = $value;
	return array_key_exists($key, $GLOBALS['__options__']) ? $GLOBALS['__options__'][$key] : null;
}

//header
function _header($value){
	static $header_set;
	if ($header_set) return;
	$header_set = 1;
	header($value);
}

//request url
function _request_url(){
	if (!(
		isset($_SERVER)
		&& is_array($_SERVER)
		&& array_key_exists($key = 'HTTP_HOST', $_SERVER)
		&& ($host = trim($_SERVER[$key]))
		&& array_key_exists($key = 'REQUEST_URI', $_SERVER)
		&& is_string($request_uri = $_SERVER[$key])
	)) return false;
	if ($query_string = array_key_exists($key = 'QUERY_STRING', $_SERVER) ? trim($_SERVER[$key]) : null){
		$request_uri = trim(str_replace($query_string, '', $request_uri), '? ');
	}
	$protocol = 'http' . (array_key_exists($key = 'HTTPS', $_SERVER) && trim($_SERVER[$key]) ? 's' : '') . '://';
	return $protocol . $host . '/' . trim($request_uri, '/');
}

//redirect
function _redirect(){
	if (!($url = _request_url())) return _failure('Unable to get the request/redirect url.');
	_header("Location: $url");
}

//echo/print
function _echo($value, $br=1, $exit_status=null){
	static $print_start;
	
	//print start
	if (!$print_start){
		$print_start = 1;
		_header('Content-type: text/plain');
		Process::print_start();
	}

	//print out
	Process::print_out($value, $br, $str);
	if (is_integer($exit_status)) exit($exit_status);
}

//failure
function _failure($error){
	_echo("FAILURE: $error", 1, 1);
}

//read
function _read($path, $assoc=0){
	if (($data = file_get_contents($path)) === false) return _failure("unable to read ($path)");
	if ($assoc && !is_array($data = json_decode($data, 1))) return _failure("invalid assoc data ($path)");
	return $data;
}

//write
function _write($path, $data, $append=0, &$bytes=null){
	$bytes = null;
	$data = is_array($data) || is_object($data) ? json_encode($data) : (string) $data;
	if (($res = @file_put_contents($path, $data, $append ? FILE_APPEND : 0)) === false) return _failure("unable write ($path)");
	$bytes = $res;
	return true;
}

//delete
function _delete($path, $fails=1){
	if (!is_file($path)) return -1;
	if (!@unlink($path)) return $fails ? _failure("unable delete ($path)") : false;
	return true;
}

//cache data
function _cache_data($data){
	if (!(
		is_array($data)
		&& isset($data[$key = 'cmd'])
		&& ($cmd = trim($data[$key]))
		&& isset($data[$key = 'pid'])
		&& ($pid = Process::pid($data[$key]))
	)) return false;
	return [
		'cmd' => $cmd,
		'pid' => $pid,
		'mypid' => _option('mypid'),
	];
}

//cache set
function _cache_set($data){
	if (!($data = _cache_data($data))) return _failure('Invalid cache data.');
	_write(_option('cache_file'), $data);
	return $data;
}

//cache get - cleanup (not running)
function _cache_get($is_running=0, $kill=0){
	if (is_file($path = _option('cache_file')) && ($data = _cache_data(_read($path, 1)))){
		if (!$is_running && !$kill) return $data; //default
		if ($pid = Process::exists($data['pid'], $err)){
			if ($kill){
				if (($res = Process::kill($pid, $error)) === false) return _failure($error);
				if ($res === 1){
					_echo('');
					_echo(sprintf('- killed [pid: %s, mypid=%s] %s', $pid, $data['mypid'], $data['cmd']));
					usleep(200 * 1000); //delay 200ms
				}
			}
			elseif ($is_running) return $data; //running
		}
		elseif ($pid === false) return _failure('Cache get process exists error: ' . $err);
	}
	if ($is_running < 0) return; //no cleanup
	_delete(_option('cache_file'));
	_delete(_option('log_file'));
}

//output buffer
function _output($data=null, $is_running=0){

	//vars
	$is_cache = !!($data = _cache_data($data));
	if (!$is_cache && !($data = _cache_get($is_running))) return;
	$cmd = $data['cmd'];
	$pid = $data['pid'];
	$mypid = $data['mypid'];
	if (!$is_cache) _echo("[pid=$pid, mypid=$mypid] $cmd");
	$_done = function($check_running=0) use (&$pid){
		if ($check_running && ($_pid = Process::exists($pid))) return $_pid;
	};
	
	//read stdout (log_file)
	if (is_file($path = _option('log_file'))){
		$res = Process::read_file($path, $pid, $_seek=0, $_print=true, $_buffer_cb=null, $error, $abort);
		if ($res === false){
			_echo("Buffer Error: $error");
			return $_done(1);
		}
		return $_done($abort);
	}
	
	//poll running
	if (!($pid = $_done(1))) return;
	$abort = 0;
	$_restore = Process::no_limit();
	$_poll_echo = function() use (&$pid){
		_echo("- poll running pid: $pid");
	};
	$_poll_echo();
	$res = Process::poll_exists($pid, false, function() use (&$abort, &$_poll_echo){
		if (connection_aborted()){
			$abort = 2;
			return true;
		}
		$_poll_echo();
	}, $_sleep_ms=1000, $_timeout=null, $error);
	$_restore();
	if ($res === false){
		_echo("Poll Error: $error");
		return $_done(1);
	}
	return $_done($abort);
}

//command line
function _command($cmd, $stdout=0, $php_self=0){
	static $php;
	if (!(is_string($cmd) && ($cmd = trim($cmd)))) return _failure('Empty command line.');
	
	//set php
	if (!$php){
		if (!($tmp = Process::find_php())) return _failure('Failed to get PHP executable path. Set it manually using $GLOBALS["__PHP_EXE__"]');
		$php = strpos($tmp, ' ') !== false ? '"' . $tmp . "'" : $tmp;
	}

	//php self
	if ($php_self) $cmd = $php . ' ' . _option('target_arg') . ' ' . $cmd;
	
	//parse cmd - check stdout, stderr
	if (strpos($cmd, '>') !== false){
		$parse = Process::parse($cmd);
		if (isset($parse['stdout']) && trim($parse['stdout'])) return _failure("command stdout pipe not supported. ($cmd)");
		if (isset($parse['stderr']) && trim($parse['stderr'])) return _failure("command stderr pipe not supported. ($cmd)");
	}

	//normalize
	if (stripos($cmd, 'php') === 0) $cmd = preg_replace('/^php(\s+)?/i', "$php\$1", $cmd);
	elseif (stripos($cmd, 'composer') === 0) $cmd = preg_replace('/^composer(\s+)?/i', "$php composer\$1", $cmd);

	//stdout log
	if ($stdout) $cmd .= ($stdout === 2 ? ' >> ' : ' > ') . _option('stdout');
	$cmd .= ' 2>&1';
	
	//result
	return $cmd;
}

//run background process
function _run_bg($cmd, $php_self=0){
	if ($pid = _output(null, 1)) return _failure("Resumed process is still running. (pid=$pid - cancel manually)");
	if (
		stripos($cmd, 'composer') !== false
		&& $cmd !== 'install-composer-worker'
		&& is_file(_option('composer_file'))
	) _putenv_composer_home();
	$_cmd = $cmd;
	$cmd = _command($cmd, 1, $php_self);
	$pid = Process::run_bg($cmd, $error);
	if (!$pid) return _failure("Process Error: $error");
	return _output(_cache_set([
		'cmd' => $_cmd,
		'pid' => $pid
	]));
}//putenv - COMPOSER_HOME
function _putenv_composer_home(){
	$dir = _option('cwd') . '/vendor/bin/composer';
	if (!is_dir($dir) && !@mkdir($dir, 0775, 1)) return _failure("Create COMPOSER_HOME dir. ($dir)");
	if (!($COMPOSER_HOME = realpath($dir))) return _failure("Invalid COMPOSER_HOME dir realpath. ($dir)");
	putenv('COMPOSER_HOME=' . $COMPOSER_HOME);
	return $COMPOSER_HOME;
}

//install composer
function _install_composer(){
	$_restore = Process::no_limit();
	try {
		
		//vars
		$cwd = _option('cwd');
		$sig_file = $cwd . '/composer.sig';
		$setup_file = $cwd . '/composer-setup.php';
		$phar_file = $cwd . '/composer.phar';
		$composer_file = _option('composer_file');
		
		//install/update
		_echo(sprintf('%s composer...', is_file($composer_file) ? 'Updating' : 'Installing'));

		//fetch copy
		$_copy = function ($source, $dest){
			$tmp = basename($dest);
			_echo("Copy: $source -> $tmp");
			if (copy($source, $dest)) return true;
			throw new Exception("Copy failed ($source -> $dest)");
		};
		
		//get signature
		_echo("\nGet setup signature...");
		$_copy('https://composer.github.io/installer.sig', $sig_file);
		$sig = trim(_read($sig_file));
		_delete($sig_file); //delete read
		_echo("Signature: $sig");
	
		//get setup (verify hash signature)
		_echo("\nGet composer setup (verify hash)...");
		$_copy('https://getcomposer.org/installer', $setup_file);
		if (hash_file('sha384', $setup_file) !== $sig){
			_delete($setup_file); //delete corrupt
			throw new Exception('Corrupt installer - deleted');
		}
		_echo('Installer verified!');
		
		//install composer
		_echo("\nInstall composer...");
		_delete($phar_file); //delete existing

		//install - foreground process
		_putenv_composer_home();
		$cmd = _command('php composer-setup.php', 0);
		$proc = new Process($cmd);
		if (!$proc -> open()) throw new Exception($proc -> error);
		_echo(sprintf('[pid=%s, mypid=%s] %s', $proc -> pid, _option('mypid'), $cmd));
		$proc -> close_pipe(0);
		$proc -> output(1);
		$proc -> close();
		
		//check installation
		if (!(is_file($phar_file) && ($phar_file = realpath($phar_file)))) throw new Exception("Installed file not found. ($phar_file)");
		_delete($setup_file); //delete setup successful
		
		//rename installed
		$tmp = basename($composer_file);
		_echo("Rename: $phar_file -> $tmp");
		_delete($composer_file); //delete existing
		if (!rename($phar_file, $composer_file)) throw new Exception("Rename failed. ($phar_file -> $composer_file)");
		
		//done
		$_restore();
		_echo('Installation complete.', 1, 0);
	}
	catch (Exception $e){
		$_restore();
		return _failure($e -> getMessage());
	}
}//check requirements
function _check_requirements(){
	
	//init vars
	$errors = [];
	$fails = 0;
	$sp = ($is_console = _option('is_console')) ? '  ' : ' ';
	$pass = '' . $sp;
	$fail = '' . $sp;

	//print helper
	$_msg = function($str, $p=null) use (&$pass, &$fail, &$fails, &$errors){
		if (!is_null($p) && !$p){
			$fails += 1;
			$errors[] = $str;
		}
		_echo(sprintf('%s%s', is_null($p) ? '' : ($p ? $pass : $fail), $str));
	};

	//test
	_echo('Checking requirements...');
	_echo('');

	//Test PHP Version >= 7.3
	$c = '7.3';
	$v = PHP_VERSION;
	if (!version_compare($v, $c, '>=')) $_msg("Error PHP Version ($v < $c).", 0);
	else $_msg("PHP Version ($v >= $c)", 1);
	
	//Test Extensions
	$required_exts = [
		'bcmath' => 'BCMath PHP Extension',
		'ctype' => 'Ctype PHP Extension',
		'fileinfo' => 'Fileinfo PHP Extension',
		'json' => 'JSON PHP Extension',
		'mbstring' => 'Mbstring PHP Extension',
		'openssl' => 'OpenSSL PHP Extension',
		'PDO' => 'PDO PHP Extension',
		'tokenizer' => 'Tokenizer PHP Extension',
		'xml' => 'XML PHP Extension',
		'gd' => 'GD PHP Extension',
	];

	//check loaded extension
	$loaded_exts = get_loaded_extensions();
	foreach ($required_exts as $ext => $title){
		if (!in_array($ext, $loaded_exts)) $_msg("Error $title ($ext) Not Loaded.", 0);
		else $_msg("Loaded $title ($ext)", 1);
	}

	//result
	_echo("\nTest " . (!$fails ? 'PASSED' : "FAILED ($fails)"));
	return !$fails;
}//test lines
function _test_lines(){
	$max = 50;
	$ms = 200;
	_echo("Test $max lines (sleep $ms ms)...");
	for ($i = 1; $i <= $max; $i ++){
		_echo("[$i/$max] - test line.");
		usleep($ms * 1000);
	}
	_echo('Test lines done.');
}

#================================  !_html    =================================
?>


<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="google" content="notranslate">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title><?php echo _option('title'); ?></title>
	<script type="text/javascript">
		window.CONFIG = <?php echo json_encode([
			'target' => _option('target'),
			'cwd' => _option('cwd'),
			'mypid' => _option('mypid'),
			'resume' => _option('resume'),
			'composer' => is_file(_option('composer_file')),
		]); ?>;
	</script>
	<style>
		.container {
			flex-grow: 1;
			display: flex;
			flex-direction: column;
			background: #fff;
			border: 1px solid #ddd;
			margin: 20px auto;
			min-width: 70%;
		}
		@media only screen and (max-width: 768px){
			.container {
				min-width: 100%;
				margin: 0 auto;
			}
		}
		.input {
			margin: 0;
			color: teal;
			outline: none;
			flex-grow: 1;
			border: 1px solid #ddd;
			padding: 4px 8px;
			font-size: 14px;
			font-weight: bold;
			font-family: 'monospace', consolas;
		}
		.label {
			width: 50px;
			color: #555;
			font-size: 14px;
			font-weight: bold;
			cursor: pointer;
		}
		.btn {
			padding: 4px 8px;
			font-size: 11px;
		}
	</style>
</head>
<body style="position:fixed;top:0;left:0;width:100%;height:100%;margin:0;font-family:'monospace',consolas;background-color:#eee;">
	<div style="position:relative;width:100%;height:100%;display:flex;flex-direction:column;">
		<div class="container">
			
			<!-- head -->
			<div style="padding:10px;text-align:center;">
				<h2 style="margin:0;font-size:16px;color:#888"><?php echo _option('title'); ?></h2>
			</div>
			
			<!-- output -->
			<div style="position:relative;flex-grow:1;">
				<div id="output_wrapper" style="display:flex;flex-direction:column;overflow:scroll;position:absolute;top:0;left:0;width:100%;height:100%;">
					<div id="output" style="flex-grow:1;background:#000;color:#9f9;padding:10px;white-space:pre-wrap;font-size:12px;"></div>
				</div>
			</div>
			
			<!-- form -->
			<form id="cmd_form" action="" method="post" style="font-size:12px;display:flex;flex-direction:column;">
				
				<!-- inputs -->	
				<div style="padding:10px;display:flex;flex-direction:column;gap:4px">
					<div style="display:flex;flex-direction:row;align-items:center;">
						<label for="input_cmd" class="label" title="Type command here">CMD:</label>
						<input id="input_cmd" class="input" style="color:blue;" type="text" value="" />
					</div>
				</div>

				<!-- buttons -->
				<div style="padding:10px 10px 20px;gap:10px;display:flex;flex-direction:row;flex-wrap:wrap;border-top:1px solid #ddd;justify-content:start;">
					<button id="btn_requirements" class="btn" type="button" title="Check Requirements">Requirements</button>
					<button id="btn_install_composer" class="btn" type="button" title="Install Composer">Install Composer</button>
					<button id="btn_clear" class="btn" type="button" title="Clear Output">Clear</button>
					<button id="btn_cancel" class="btn" type="button" title="Cancel Running">Cancel</button>
				</div>
			</form>
		</div>
	</div>
	<script type="text/javascript">
		
		//config
		let IS_CANCELLED, RUN_TEST, IS_DISABLED, ENDPOINT = window.location.href, CONFIG = window.CONFIG || {};
		Object.entries(CONFIG).forEach(entry => {
			let [key, val] = entry;
			if (!val) return;
			if ('object' === typeof val) val = Object.values(val).join(' ');
			console.log(`%c${key.toUpperCase()}`, 'color:blue', val);
		});
		
		//output wrapper - scroll
		const output_wrapper = document.getElementById('output_wrapper');
		let output_scroll_ignore = 0;
		output_wrapper.addEventListener('scroll', () => {
			if (output_scroll_ignore === 1) return output_scroll_ignore = 0;
			output_scroll_ignore = 2;
			const el = output_wrapper, offset = 20;
			if (el.scrollHeight < el.offsetHeight || (el.scrollHeight - el.scrollTop - el.offsetHeight) < offset) output_scroll_ignore = 0;
		}, {passive: true});
		const outputScrollBottom = () => {
			if (output_scroll_ignore > 1 || output_wrapper.scrollHeight < output_wrapper.scrollHeight) return;
			output_scroll_ignore = 1;
			output_wrapper.scrollTop = output_wrapper.scrollHeight;
		};

		//output - text
		const output = document.getElementById('output');
		const output_prompt = '>_';
		const outputClear = text => output.innerText = output_prompt;
		const outputText = (text, is_cmd) => {
			let out = output.innerText.replace(new RegExp(`\n?${output_prompt}\s*$`, 'g'), '');
			if (is_cmd) out = out.trim();
			if (is_cmd && out.length) out += new RegExp('(\n|^)>[^\n]*$').test(out) ? '\n' : '\n\n';
			output.innerText = out + String(text);
			outputScrollBottom();
		};
		const outputPrompt = () => {
			let out = output.innerText.trim();
			if (out.length) out += new RegExp('(\n|^)>[^\n]*$').test(out) ? '\n' : '\n\n';
			output.innerText = out + output_prompt;
			outputScrollBottom();
		};
		const outputCmd = cmd => {
			//outputText((output.innerText.indexOf('\n') > -1 ? '\n' : '') + '> ' + cmd + '\n');
			outputText('> ' + cmd + '\n', 1);
		};

		//controls
		const cmd_form = document.getElementById('cmd_form');
		const input_cmd = document.getElementById('input_cmd');
		const btn_requirements = document.getElementById('btn_requirements');
		const btn_install_composer = document.getElementById('btn_install_composer');
		const btn_clear = document.getElementById('btn_clear');
		const btn_cancel = document.getElementById('btn_cancel');

		//disabled
		const setDisabled = (disabled=true, cancel) => {
			IS_DISABLED = disabled = !!disabled;
			cancel = cancel === undefined ? !disabled : !!cancel;
			[btn_requirements, btn_install_composer, btn_clear].forEach(element => {
				if (disabled) element.setAttribute('disabled', 'disabled');
				else element.removeAttribute('disabled');
			});
			if (cancel) btn_cancel.setAttribute('disabled', 'disabled');
			else btn_cancel.removeAttribute('disabled');
			if (disabled) input_cmd.setAttribute('readonly', 'readonly');
			else input_cmd.removeAttribute('readonly');
		};
		const isDisabled = () => {
			if (IS_DISABLED){
				console.warn('Controls are disabled.');
				return true;
			}
			return false;
		};

		//fetch request
		const fetchRequest = async (url, options, onRead) => {
			let RESPONSE, RESPONSE_DATA;
			onRead = 'function' === typeof onRead ? onRead : undefined;
			return window.fetch(url, options).then(async res => {
				RESPONSE = res.clone();
				const decoder = new TextDecoder();
				const reader = res.body.getReader();
				const data = {text: '', contentType: res.headers.get('Content-Type')};
				return await readChunk();
				async function readChunk(){
					return reader.read().then(appendChunks);
				}
				async function appendChunks(result){
					const done = Boolean(result.done);
					const chunk = decoder.decode(result.value || new Uint8Array(), {stream: !done});
					if (onRead) onRead({buffer: chunk, response: RESPONSE});
					data.text += chunk;
					if (!done) return readChunk();
					return data;
				}
			})
			.then(data => {
				const {contentType, text} = data;
				data.json = undefined;
				RESPONSE_DATA = data;
				if (String(contentType).toLowerCase().indexOf('application/json') > -1){
					try {
						data.json = JSON.parse(text);
					}
					catch (e){
						console.warn(`Error parsing json (${contentType}) text.`, e);
					}
				}
				if (!RESPONSE.ok || !(RESPONSE.status >= 200 && RESPONSE.status < 300)){
					let err = `Request error ${RESPONSE.status}: ${RESPONSE.statusText}`;
					console.warn(err, {RESPONSE, data})
					throw new Error(err);
				}
				return {error: undefined, data, response: RESPONSE};
			})
			.catch(error => Promise.reject({error, data: RESPONSE_DATA, response: RESPONSE}));
		};

		//fetch exec
		let ABORT_CONTROLLER, FETCH_EXEC = 0;
		const fetchAbort = () => ABORT_CONTROLLER?.abort?.();
		const fetchExec = async (cmd, is_cancel=false) => {
			
			//fetch busy
			let signal;
			if (!is_cancel){
				if (FETCH_EXEC) return console.warn('Fetch exec is busy.');
				FETCH_EXEC = 1;
				setDisabled(true);
				outputCmd(cmd);
				ABORT_CONTROLLER = new AbortController();
				signal = ABORT_CONTROLLER.signal;
			}

			//fetch request
			const formData = new FormData();
			formData.append('cmd', cmd);
			const options = {
				signal,
				method: 'POST',
				body: formData,
			};

			//result - fetch request promise
			return fetchRequest(ENDPOINT, options, ({buffer, response}) => {
				if (response.ok) outputText(buffer);
			})
			.catch(err => {
				if (err?.error instanceof Error){
					if (err.error.name !== 'AbortError') console.warn(err.error);
					return;
				}
				return Promise.reject(err);
			})
			.finally(() => {
				if (is_cancel) return;
				FETCH_EXEC = 0;
				if (IS_CANCELLED) return IS_CANCELLED();
				setDisabled(false);
				outputPrompt();
				input_cmd.focus();
			});
		}
		const fetchCancel = async () => {
			if (RUN_TEST) RUN_TEST = undefined;
			if (IS_CANCELLED) return console.warn('Fetch cancel is busy.');

			//cancel busy
			const callback = () => {
				setDisabled(false);
				outputPrompt();
				input_cmd.focus();
				IS_CANCELLED = undefined;
			};
			IS_CANCELLED = () => callback();
			setDisabled(true, true);
			outputCmd('cancel');

			//cancel fetch
			if (FETCH_EXEC){
				fetchAbort();
				return fetchExec('cancel', true)
				.finally(() => {
					if (FETCH_EXEC) return;
					callback();
				});
			}

			//cancel done
			return callback();
		};

		//run test
		const runTest = () => {
			RUN_TEST = 1;
			setDisabled(true);
			outputCmd('run test (js)');
			let x = 0, max = 100, interval = setInterval(() => {
				x ++;
				if (RUN_TEST) outputText(`[${x}/${max}] - test line.\n`);
				if (x === max || !RUN_TEST){
					clearInterval(interval);
					if (IS_CANCELLED) return IS_CANCELLED();
					setDisabled(false);
				}
			}, 200);
		};

		//run actions
		const ACTIONS = {
			'cancel': () => fetchCancel(),
			'clear': () => {
				if (isDisabled()) return;
				fetchExec('clear')
				.then(() => {
					outputClear();
					input_cmd.value = '';
					input_cmd.focus();
				});
			},
			'exec': (cmd) => {
				if (isDisabled()) return;
				fetchExec(cmd);
			},
			'cmd': () => {
				if (isDisabled()) return;
				const cmd = input_cmd.value.trim();
				input_cmd.value = '';
				if (!cmd.length) return;
				let tmp = cmd.toLowerCase();
				if (ACTIONS.hasOwnProperty(tmp)) return ACTIONS[tmp]();
				return ACTIONS.exec(cmd);
			},
			'test': () => ACTIONS.exec('test'),
			'run-test': () => {
				if (isDisabled()) return;
				runTest();
			},
			'requirements': () => ACTIONS.exec('requirements'),
			'install-composer': () => ACTIONS.exec('install-composer'),
			'resume': () => ACTIONS.exec('resume'),
		};
		
		//action events
		cmd_form.addEventListener('submit', e => {
			e.preventDefault();
			ACTIONS.cmd();
		});
		btn_requirements.addEventListener('click', e => {
			e.preventDefault();
			ACTIONS.requirements();
		});
		btn_install_composer.addEventListener('click', e => {
			e.preventDefault();
			ACTIONS['install-composer']();
		});
		btn_clear.addEventListener('click', e => {
			e.preventDefault();
			ACTIONS.clear();
		});
		btn_cancel.addEventListener('click', e => {
			e.preventDefault();
			ACTIONS.cancel();
		});

		//initialize
		outputClear();
		input_cmd.placeholder = output_prompt;
		input_cmd.focus();
		setDisabled(false);
		if (CONFIG.composer) btn_install_composer.style.display = 'none';
		if (CONFIG.resume) ACTIONS.resume();
	</script>
</body>
</html>