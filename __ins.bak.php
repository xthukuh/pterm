<?php

$GLOBALS['__TARGET__'] = __FILE__;
$GLOBALS['__args__'] = isset($argv) ? $argv : null;

#================================  _main    =================================

//global options
Process::$VERBOSE = 1;
$cwd = getcwd();
$options = [
	'title' => 'NCMS Admin',
	'mypid' => getmypid(),
	'stdout' => ($tmp = '__install.log'),
	'log_file' => $cwd . '/' . $tmp,
	'pid_file' => $cwd . '/__install.pid',
	'tmp_file' => $cwd . '/__install.tmp',
	'err_file' => $cwd . '/__install_error.log',
	'target' => $GLOBALS['__TARGET__'],
	//'target' => '__ins.php',
	'method' => ($method = isset($_SERVER) && isset($_SERVER['REQUEST_METHOD']) ? strtolower($_SERVER['REQUEST_METHOD']) : null),
	'request' => isset($_REQUEST) ? $_REQUEST : null,
	'cwd' => $cwd,
	'cmd' => null,
	'worker' => null,
	'resume' => null,
	'page' => $method === 'get' ? 1 : 0,
	'args' => isset($argv) ? $argv : null,
	'__args__' => $GLOBALS['__args__'],
	'is_console' => Process::is_console(),
];
if (isset($argv) && is_array($argv) && ($len = count($argv))){
	if (isset($argv[1]) && ($val = trim($argv[1]))) $options['cmd'] = $val;
}
else {
	if (!empty($_REQUEST)){
	    if ($options['method'] === 'get') $options['page'] = -1;
		if (
		    in_array($options['method'], ['get', 'post'])
			&& array_key_exists('cmd', $_REQUEST)
			&& ($val = trim($_REQUEST['cmd']))
		){
		    $options['cmd'] = $val;
		    $options['page'] = 0;
		}
	}
	if ($options['page'] < 0){
	    _redirect();
	    exit;
	}
}
$GLOBALS['__options__'] = $options;
if (!is_file(_option('target'))) _failure('Installer target file is invalid!');

//handle command
if ($cmd = _option('cmd')){
    switch (strtolower($cmd)){
		case 'requirements':
		    //_run_cached('/usr/local/bin/php __ts.php test-requirements');
		    _run_cached('php self test-requirements');
			//_run_cached(sprintf('/usr/local/bin/php __ts.php %s', escapeshellcmd('test-requirements')));
			/*
			$cmd = _command(sprintf('/usr/local/bin/php %s %s', escapeshellcmd(getcwd() . '/__inc2.php'), escapeshellcmd('test-requirements')), 1) . ' & echo $!';
			_echo("shell_exec> $cmd");
			$out = shell_exec($cmd);
			_echo("output: $output");
			/*
			_echo("[exec]> $cmd");
			if (exec($cmd, $output, $exit) === false) _failure("exec() failed!");
			_echo(['output' => $output, 'exit' => $exit], 1, 0);
			//*/
			break;
		case 'test-requirements':
			_test_requirements();
			break;
		case 'test':
			_run_cached('php self test-lines');
			break;
		case 'test-lines':
			_test_lines();
			break;
		case 'install-composer':
			_worker_install_composer();
			break;
		case 'resume':
			_run_resume();
			break;
		case 'cancel':
			_echo('>> Cancel...');
			_cache_get(1, 1);
			exit(0);
			break;
		case 'clear':
			_echo('>> Cleanup...');
			if (!_option('method')) sleep(1);
			_cache_get(1);
			_delete(Process::$LOG_FILE, 0);
			_delete('__ts.log', 0);
			exit(0);
			break;
		default:
			_run_cached($cmd);
			break;
	}
}

//show page
if (!$options['page']){
    //_echo(['options' => _option()]);
    exit(2);
}
_option('resume', _cache_get(1));

#================================  Process  =================================

class Process
{
	/**
	 * exe suffixes.
	 * 
	 * @var array
	 */
	const EXE_SUFFIXES = ['.EXE', '.BAT', '.CMD', '.COM'];

	/**
	 * process options (proc_open args)
	 * 
	 * - REF: https://www.php.net/manual/en/function.proc-open.php
	 * 
	 * @var array
	 */
	const OPTIONS = [
		'descriptor_spec' => null,	//(array) file descriptors [default: self::DESCRIPTOR_SPEC]
		'cwd' => null,				//working directory [default: getcwd()]
		'env_vars' => null,			//(assoc array) environment variables [default: getenv()]
		'other_options' => null,	//(assoc array) other options [default (windows): self::WIN_OPTIONS]
	];

	/**
	 * default file descriptors
	 * 
	 * @var array
	 */
	const DESCRIPTOR_SPEC = [
		0 => ['pipe', 'r'],	//stdin
		1 => ['pipe', 'w'],	//stdout
		2 => ['pipe', 'w'],	//stderr
	];

	/**
	 * default windows platform options (other_options).
	 * 
	 * @var array
	 */
	const WIN_OPTIONS = [
		'suppress_errors' => false,			//suppresses errors generated by this function when it's set to true
		'bypass_shell' => false,			//bypass cmd.exe shell when set to true
		'blocking_pipes' => false,			//force blocking pipes when set to true
		'create_process_group' => false,	//allow the child process to handle CTRL events when set to true
		'create_new_console' => false,		//the new process has a new console, instead of inheriting its parent's console
	];
	
	/**
	 * verbose log mode (0=disabled, 1=all, 2=normal/high/error, 3=high/error, 4=error)
	 * 
	 * @var int
	 */
	public static $VERBOSE = 0;

	/**
	 * verbose log file path
	 * 
	 * @var string
	 */
	public static $LOG_FILE = '__process_verbose.log';

	/**
	 * process error message (if failed)
	 * 
	 * @var string
	 */
	private $_error;

	/**
	 * process state (one of: [null, 'failing', 'failed', 'opening', 'open', 'closing', 'closed', 'shutdown'])
	 * 
	 * @var string
	 */
	private $_state;

	/**
	 * process config data (see static::config())
	 * 
	 * @var array
	 */
	private $_config;

	/**
	 * process resource.
	 * 
	 * @var resource
	 */
	private $_process;

	/**
	 * process resource pipes
	 * 
	 * @var array
	 */
	private $_pipes;

	/**
	 * exit result code (proc_close() result)
	 * 
	 * @var int
	 */
	private $_exit;

	/**
	 * opened process ID (PID: end($this -> pids))
	 * 
	 * @var int
	 */
	private $_pid;

	/**
	 * opened processes ID (PID array)
	 * 
	 * @var array
	 */
	private $_pids;

	/**
	 * new instance
	 * 
	 * @param  string	$cmd		- command line string
	 * @param  array	$options	- process options (proc_open args)
	 * @param  bool		$background	- process runs in the background
	 * @return void
	 */
	public function __construct($cmd, $options=null, $background=false){
		$config = static::config($cmd, $options, $background, $_as_win=null, $error);
		if (!$config) $this -> _failure("Construct config failure: $error");
		else $this -> _config = $config;
	}

	/**
	 * verbose log
	 * 
	 * @param  string	$message	- log message
	 * @param  int		$level		- log level (0=low, 1=normal, 2=high, 3=error)
	 * @return void
	 */
	private static function _verbose($message, $level=0){
		static $path;
		if (!$path) $path = is_string($tmp = self::$LOG_FILE) && ($tmp = trim($tmp)) ? $tmp : '__process_verbose.log';
		if (($verbose = (int) self::$VERBOSE) <= 0) return;
		if ($level < ($verbose - 1)) return;
		$datetime = (new DateTime()) -> format('Y-m-d H:i:s');
		$data = rtrim("[$datetime - $level] $message") . "\n";
		if (!@file_put_contents($path, $data, FILE_APPEND)) throw new Exception("Failed to append contents ($path)");
	}

	/**
	 * disable verbose for callback
	 * 
	 * @param  callable	$handler	- callback method
	 * @return void
	 */
	private static function _no_verbose($handler){
		if (!is_callable($handler)) return;
		$tmp = self::$VERBOSE;
		self::$VERBOSE = 0;
		try {
			call_user_func($handler);
			self::$VERBOSE = $tmp;
		}
		catch (Exception $e){
			self::$VERBOSE = $tmp;
			throw $e;
		}
	}

	/**
	 * handle process failure
	 * 
	 * @param  $error  - error message
	 * @return false
	 */
	private function _failure($error){
		if (self::$VERBOSE) static::_verbose("> FAILURE: $error", 3);
		$this -> _status = 'failing';
		$this -> close($_kill=1);
		$this -> _error = $error;
		$this -> _status = 'failed';
		return false;
	}
	
	/**
	 * get property value
	 * 
	 * @param  string  $name	- property name
	 * @return mixed
	 */
	public function __get($name){
		static $props = ['error', 'state', 'config', 'exit', 'pid', 'pids'];
		if (in_array($name, $props)){
			if (property_exists($this, $prop = "$name")) return $this -> {$prop};
			if (property_exists($this, $prop = "_$name")) return $this -> {$prop};
		}
		throw new Exception(sprintf('Property name "%s" is not available.', $name));
	}

	/**
	 * close process (proc_close)
	 * 
	 * @param  bool	$kill	- Kill running process.
	 * @return void
	 */
	public function close($kill=false){
		$kill = !!$kill;
		
		//closing
		if (strpos($state = $this -> _state, 'open') !== false) $this -> _state = $state = 'closing';
		elseif (strpos($state, 'clos') !== false) return; //ignore if closing/closed
		if (self::$VERBOSE) static::_verbose(sprintf('> $this -> close($kill=%s)', json_encode($kill)), 1);
		
		//kill running (temporarily disable debugging)
		if ($kill){
			$tmp = self::$VERBOSE;
			static::_no_verbose(function() use (&$tmp){
				if (is_array($pids = $this -> _pids) && ($len = count($pids))){
					for ($i = ($len - 1); $i >= 0; $i --){
						$pid = $pids[$i];
						$killed = static::kill($pid);
						if ($tmp){
							self::$VERBOSE = $tmp;
							static::_verbose(sprintf('- closing -> kill(pid=%s) = %s', $pid, json_encode($killed)));
							self::$VERBOSE = 0;
						}
					}
				}
			});
		}

		//close pipes
		if (is_array($this -> _pipes)){
			foreach ($this -> _pipes as $i => &$pipe){
				if (is_resource($pipe)){
					$res = fclose($pipe);
					if (self::$VERBOSE) static::_verbose(sprintf('- fclose($this -> _pipes[%s]) -> %s', $i, json_encode($res)));
				}
			}
			$this -> _pipes = null;
		}

		//close process
		if (is_resource($this -> _process)){
			$this -> _exit = $exit = proc_close($this -> _process);
			$this -> _process = null;
			if (self::$VERBOSE) static::_verbose(sprintf('- proc_close($this -> _process) -> %s', json_encode($exit)));
		}

		//closed state
		if ($state === 'closing') $this -> _state = 'closed';
	}

	/**
	 * shutdown open process
	 * 
	 * @return void
	 */
	public function shutdown(){
		if (strpos($state = $this -> _state, 'open') === false) return;
		if (self::$VERBOSE) static::_verbose(sprintf('> $this -> shutdown() - (state: %s)', $state), 1);
		$this -> _state = 'shutdown';
		$this -> close(1);
	}

	/**
	 * process status (proc_get_status).
	 * 
	 * @param  int  $pid		- ByRef process pid.
	 * @param  int  $running	- ByRef (int/bool) process is running.
	 * @return array
	 */
	public function status(&$pid=null, &$running=null){
		$pid = null;
		$running = null;
		$status = is_resource($this -> _process) && is_array($val = proc_get_status($this -> _process)) ? $val : [];
		if (array_key_exists($key = 'pid', $status) && ($val = static::pid($status[$key]))) $pid = $val;
		if (array_key_exists($key = 'running', $status)) $running = (int) (!!$status[$key]);
		return $status;
	}

	/**
	 * open process (proc_open)
	 * 
	 * ~ callback results
	 * - if callback returns true:	prevents running process close (you will need to call $self -> close() manually [automatically closed by shutdown handler])
	 * - if callback returns false:	kill/close running process
	 * 
	 * @param  callable	$open_callback	- process opened callback (i.e function(Process $self){...})
	 * @param  bool		$get_child		- sets PIDs ($self -> pids) if enabled - always enabled if $background is enabled.
	 * @return null|bool				- null if cancelled (ignored) | true on success | false on error
	 */
	public function open($open_callback=null, $get_child=false){
		$open_callback = is_callable($open_callback) ? $open_callback : null;
		$get_child = !!$get_child;

		//check config
		if (!($config = $this -> _config)) return $this -> _failure(trim('Open process config is undefined. ' . $this -> _error));
		if (($background = $config['background']) && !$get_child) $get_child = 'BG';

		//opening
		if (($state = $this -> _state) === 'opening') return; //ignore opening
		if (self::$VERBOSE){
			static::_verbose(sprintf('> $this -> open($open_callback=%s, $get_child=%s) %s', $open_callback ? 'callable' : 'null', is_string($get_child) ? $get_child : json_encode($get_child), $config['command']), 1);
			static::_verbose(sprintf('- config: %s', json_encode($config)));
		}
		if ($state === 'open') $this -> close(1); //close/kill open
		$this -> _state = 'opening';
		
		//reset props
		$this -> _process = null;
		$this -> _pipes = null;
		$this -> _exit = null;
		$this -> _pid = null;
		$this -> _pids = null;
		
		//open process
		$command = $config['command'];
		$this -> _process = proc_open($command, $config['descriptor_spec'], $this -> _pipes, $config['cwd'], $config['env_vars'], $config['other_options']);
		if (!is_resource($this -> _process)){
			if (self::$VERBOSE) static::_verbose("proc_open failure - error_get_last:\n" . print_r(error_get_last(), 1));
			return $this -> _failure(sprintf('Open process failure. (%s)', $command));
		}

		//opened process - status/pid
		if (!(!empty($this -> status($pid, $running)) && $pid)) return $this -> _failure(sprintf('Unable to get opened process status/pid. (%s)', $command));
		if (self::$VERBOSE) static::_verbose(sprintf('~ process opened (pid=%s, running=%s, mypid=%s)', $pid, $running, getmypid()), 1);
		
		//open state
		$this -> _state = 'open';
		
		//set PIDs
		$pids = [$pid];
		if ($get_child){
			if (!($child_pid = static::child($pid, $_pids, $err))){
				$this -> status($_pid, $_running);
				if ($_pid === $pid && !$_running) $running = 0; //ignore not running
				else return $this -> _failure(sprintf('Get child [%s] failure: %s (%s)', $pid, $err, $command));
			}
			$pids = array_merge($pids, $_pids);
			if ($child_pid) $pid = $child_pid;
		}
		$this -> _pid = $pid;
		$this -> _pids = $pids;

		//open callback
		$result = null;
		if ($open_callback){
			if (self::$VERBOSE) static::_verbose('- open callback');
			if (!$background) register_shutdown_function([$this, 'shutdown']);
			try {
				$result = call_user_func_array($open_callback, [$this]);
				if (self::$VERBOSE) static::_verbose(sprintf('- open callback result=%s', json_encode($result)));
			}
			catch (Exception $e){
				return $this -> _failure('Open callback exception: ' . $e -> getMessage());
			}
		}

		//close process
		if ($result === false) $this -> close(1);
		elseif ($result !== true) $this -> close();

		//success
		return true;
	}

	/**
	 * get running PID
	 * 
	 * @return int|null  - PID or null if not found
	 */
	public function running(){
		$running_pid = null;
		static::_no_verbose(function() use (&$running_pid){
			if (is_resource($this -> _process)){
				$this -> status($pid, $running);
				if ($running) $running_pid = $pid;
			}
			if (!$running_pid && is_array($this -> _pids)){
				foreach ($this -> _pids as $pid){
					if (static::exists($pid)){
						$running_pid = $pid;
						break;
					}
				}
			}
		});
		if (self::$VERBOSE) static::_verbose(sprintf('> $this -> running() = %s', json_encode($running_pid)), 1);
		return $running_pid;
	}

	/**
	 * get pipe resource
	 * 
	 * @param  int  $index	- pipe index (0 = stdin, 1 = stdout, 2 = stderr) [default=1].
	 * @return resource|null
	 */
	public function pipe($index=1){
		if (is_array($this -> _pipes) && isset($this -> _pipes[$index]) && is_resource($pipe = &$this -> _pipes[$index])) return $pipe;
	}

	/**
	 * close pipe resource
	 * 
	 * @param  int  $index	- pipe index (0 = stdin, 1 = stdout, 2 = stderr)
	 * @return bool			- success
	 */
	public function close_pipe($index){
		$result = true;
		if ($pipe = $this -> pipe($index)) $result = fclose($pipe);
		return $result;
	}

	/**
	 * process read output
	 * 
	 * @param  bool		$print				- buffer print
	 * @param  array	$buffer_callback	- buffer callback [return false to abort read] (i.e. function(string $buffer){...})
	 * @param  resource	$resource			- resource pipe/path [default: $this -> pipe(1)]
	 * @param  string	$error				- ByRef error message
	 * @param  int		$abort				- ByRef abort status (0=no abort, 1=callback abort, 2=connection abort)
	 * @return string|false					- read contents or false on error
	 */
	public function output($print=false, $buffer_callback=null, $resource=null, &$error=null, &$abort=null){
		$error = null;
		$abort = null;
		if (is_string($resource) && ($path = trim($resource))) return static::read_file($path, $this -> running(), $_seek=0, $print, $buffer_callback, $error, $abort);
		else if (is_resource($resource)) return static::read_pipe($resource, $print, $buffer_callback, $error, $abort);
		return static::read_pipe($this -> pipe(1), $print, $buffer_callback, $error, $abort);
	}

	/**
	 * is windows platform
	 * 
	 * @param  string  $uname - ByRef php_uname result
	 * @return bool
	 */
	public static function is_win(&$uname=null){
		static $_is_win, $_uname;
		if (!is_bool($_is_win)){
			$_is_win = stripos($_uname = php_uname('s'), 'win') > -1;
			if (self::$VERBOSE) static::_verbose(sprintf('> static::is_win(uname=%s) = %s', $_uname, json_encode($_is_win)));
		}
		$uname = $_uname;
		return $_is_win;
	}

	/**
	 * check if process is running on console.
	 * 
	 * @return int  - mode (0=not console, 1=non-interactive, 2=interactive)
	 */
	public static function is_console(){
		static $value;
		if (!is_integer($value)){
			$value = in_array(strtolower(php_sapi_name()), ['cli', 'phpdbg']) ? (defined('STDIN') && stream_isatty(STDIN) ? 2 : 1) : 0;
			if (self::$VERBOSE) static::_verbose(sprintf('> static::is_console() = %s', $value));
		}
		return $value;
	}

	/**
	 * parse process options
	 * 
	 * - result (see const OPTIONS)
	 * 
	 * @param  array	$options	- process options
	 * @param  bool		$as_win		- parse options for windows platform [default: static::is_win()]
	 * @param  string	$error		- ByRef error message
	 * @return array|false			- options array or false on error
	 */
	public static function options($options=null, $as_win=null, &$error=null){
		$error = null;
		try {
			
			//vars
			$opts = self::OPTIONS;
			$options = is_array($options) ? $options : [];
			$as_win = is_null($as_win) ? static::is_win() : !!$as_win;
			
			//helper method - check if value is an associative array
			$_is_assoc = function($val){
				return is_array($val) && ($c = count($val)) && array_keys($val) !== range(0, $c - 1);
			};
			
			//options - descriptor_spec
			$descriptor_spec = self::DESCRIPTOR_SPEC;
			if (array_key_exists($key = 'descriptor_spec', $options)){
				$descriptor_spec = [];
				if (!empty($val = $options[$key])){
					if (!is_array($val)) throw new Exception(sprintf('Options descriptor_spec value is not an array. ([%s] %s)', gettype($val), json_encode($val)));
					foreach ($val as $i => $v){
						if (!(is_integer($i) && $i >= 0)) throw new Exception(sprintf('Options descriptor_spec entry key is not a valid integer. ([%s] %s)', gettype($i), $i));
						if (is_array($v)) $descriptor_spec[$i] = $v;
						elseif (!empty($v)) throw new Exception(sprintf('Options descriptor_spec entry value is invalid. (%s => [%s] %s)', $i, gettype($v), json_encode($v)));
					}
				}
			}
			$opts[$key] = $descriptor_spec;
	
			//options - cwd
			$cwd = null;
			if (array_key_exists($key = 'cwd', $options)){
				if (!empty($val = $options[$key])){
					if (($path = realpath(trim($val))) === false) throw new Exception(sprintf('Options cwd value is not a real path. ([%s] %s)', gettype($val), $val));
					if (!is_dir($path)) throw new Exception(sprintf('Options cwd path value is not a directory. (%s)', $path));
					$cwd = $path;
				}
			}
			$opts[$key] = $cwd;

			//options - env_vars
			//$env_vars = getenv();
			//$env_vars['COMPOSER_HOME'] = getcwd();
			$env_vars = [];
			if (array_key_exists($key = 'env_vars', $options)){
			    $env_vars = [];
				if (!empty($val = $options[$key])){
					if (!$_is_assoc($val)) throw new Exception(sprintf('Options env_vars value is not an associative array. ([%s] %s)', gettype($val), json_encode($val)));
					foreach ($val as $i => $v){
						if (!empty($v)) $env_vars[$i] = $v;
					}
				}
			}
			$opts[$key] = !empty($env_vars) ? $env_vars : null;

			//options - other_options
			$other_options = $as_win ? self::WIN_OPTIONS : [];
			if (array_key_exists($key = 'other_options', $options)){
				$other_options = [];
				if (!empty($val = $options[$key])){
					if (!$_is_assoc($val)) throw new Exception(sprintf('Options other_options value is not an associative array. ([%s] %s)', gettype($val), json_encode($val)));
					foreach ($val as $i => $v){
						if (!empty($v)) $other_options[$i] = $v;
					}
				}
			}
			$opts[$key] = !empty($other_options) ? $other_options : null;

			//result
			return $opts;
		}
		catch (Exception $e){
			$error = $e -> getMessage();
			return false;
		}
	}

	/**
	 * parse command line string
	 * 
	 * - result [
	 *    'cmd' => null,			//(string) normalized command line string
	 *    'cmd_bg' => null,			//(string) background command line string
	 *    'stdout' => null,			//(string) parsed command stdout (i.e. '> output.log')
	 *    'stdout_path' => null,	//(string) parsed command stdout path (i.e. 'output.log')
	 *    'stderr' => null,			//(string) parsed command stderr (i.e. '> error.log')
	 *    'stderr_path' => null,	//(string) parsed command stderr path (i.e. 'error.log')
	 *    'stderr_merge' => 0,		//(int/bool) whether command has 2>&1
	 * ];
	 * 
	 * - 'cmd_bg' format - windows platform: "start /b /separate [COMMAND] >nul 2>&1 &"
	 * - 'cmd_bg' format - other platform (linux/unix): "[COMMAND] >/dev/null 2>&1 & echo &!"
	 * 
	 * @param  string	$cmd	- command line string
	 * @param  bool		$as_win	- parse command for windows platform [default: static::is_win()]
	 * @param  string	$error	- ByRef error message
	 * @return array			- parsed command data or false on error
	 */
	public static function parse($cmd, $as_win=null, &$error=null){
		static $_get_output, $_quote_restore;
		$error = null;

		//check command - replace unusual whitespace
		if (!(is_string($cmd) && ($tmp = trim(str_replace(urldecode('%C2%A0'), ' ', $cmd))))){
			if (is_string($cmd) || is_null($cmd)) $error = 'Empty command line string.';
			else $error = sprintf('Invalid command line string. ([%s] %s)', gettype($cmd), json_encode($cmd));
			return false;
		}
		else $cmd = $tmp;
		
		//vars
		$as_win = is_null($as_win) ? static::is_win() : !!$as_win;
		$stdout_path = $stderr_path = $stdout = $stderr = $tmp = $stderr_merge = null;
		$s = $cmd;
		
		//backup quotes
		$q = -1;
		$quote = [];
		if (strpos($s, '\'') !== false || strpos($s, '"') !== false){
			
			//quote - "
			$s = preg_replace_callback('/\'([^\']+)\'/', function($match) use (&$quote, &$q){
				$q ++;
				$quote[$tmp = '__' . $q . '__'] = $match[0];
				return $tmp;
			}, $s);

			//quote - '
			$s = preg_replace_callback('/"([^"]+)"/', function($match) use (&$quote, &$q){
				$q ++;
				$quote[$tmp = '__' . $q . '__'] = $match[0];
				return $tmp;
			}, $s);

			//helper method - quote restore
			if (!$_quote_restore) $_quote_restore = function($str, $q, $quote){
				$i = $key = null;
				for ($i = $q; $i >= 0; $i --){
					$key = '__' . $i . '__';
					$str = str_replace($key, $quote[$key], $str);
				}
				unset($i, $key);
				return $str;
			};
		}

		//parse command pipe
		if (strpos($s, '>') !== false){
			$stdout_append = 0;
			$stderr_append = 0;

			//check stdout
			if (preg_match('/(1| )\>\>/', $s)) $stdout_append = 1;
			
			//check stderr
			if (preg_match('/2\>\>/', $s)) $stderr_append = 1;
			
			//normalize stdout/stderr
			$s = preg_replace('/\>+/', '>', $s);
			$s = preg_replace('/([^\>]+\=[12])\>/', '$1 >', $s);
			$s = preg_replace('/([^12]+)\>/', '$1-1>', $s, 1);
			$s = preg_replace('/([^12]+)\>/', '$1-2>', $s, 1);
			$s = preg_replace('/-([12])\>/', '$1>', $s, 1);
			$s = preg_replace('/&([12])\>/', '$1>', $s);
			$s = preg_replace('/([^\>]+)([12])\>/', '$1 $2>', $s);

			//trim extra whitespace
			$s = preg_replace('/[ ]+/', ' ', $s);
			$s = preg_replace('/\s*&([12])/', '&$1', $s);

			//has 2>&1 (merge stderr & stdout)
			if (strpos($s, '2>&1') !== false){
				$stderr_merge = 1;
				$s = trim(str_replace('2>&1', '', $s));
			}

			//helper method - get stdout/stderr path
			if (!$_get_output) $_get_output = function($_cmd, $_as_win, $_stderr_path=0){
				$a = $_stderr_path ? 2 : 1;
				$b = $_stderr_path ? 1 : 2;
				$p = $x = $d = $v = null;
				if (!(($p = strpos($_cmd, "$a>")) !== false && ($p += 2))) return;
				if (($p = strpos($_cmd, "$a>")) !== false && ($p += 2)){
					$x = ($x = strpos($_cmd, "$b>", $p)) !== false ? $x : (($x = strpos($_cmd, '>', $p)) !== false ? $x : -1);
					$v = ($d = $x < 0 ? 0 : $x - $p) ? substr($_cmd, $p, $d) : substr($_cmd, $p);
					if (!strlen($v = trim($v))) $v = null;
					elseif (!preg_match(sprintf('/^[^%s]*$/', preg_quote('*?"<>|:&', '/')), $v)) $v = null;
					elseif (in_array(strtolower($v), ['nul', 'null', '/dev/null'])) $v = $_as_win ? 'nul' : '/dev/null';
				}
				unset($a, $b, $p, $x, $d);
				return $v;
			};

			//set stdout/stderr
			$stdout_path = ($tmp = $_get_output($s, $as_win)) ? $tmp : null;
			$stderr_path = ($tmp = $_get_output($s, $as_win, 1)) ? $tmp : null;
			$stdout = $stdout_path ? ($stdout_append ? '>>' : '>') . $stdout_path : null;
			$stderr = $stderr_path ? '2' . ($stderr_append ? '>>' : '>') . $stderr_path : null;
			unset($stdout_append, $stderr_append);

			//remove stdout/stderr from command line
			$s = preg_match('/^(.+?(?=[0-9]*\>))/', $s, $matches) && count($matches) ? trim($matches[0]) : trim($s);
		}

		//restore quotes
		if ($q > -1 && !empty($quote) && $_quote_restore){
			$s = $_quote_restore($s, $q, $quote);
			if ($stdout) $stdout = $_quote_restore($stdout, $q, $quote);
			if ($stderr) $stderr = $_quote_restore($stderr, $q, $quote);
		}

		//set normalized/background command
		$bg = $s;
		if ($stdout){
			$s .= ($tmp = ' ' . $stdout);
			$bg .= $tmp;
		}
		else $bg .= ' >' . ($as_win ? 'nul' : '/dev/null');
		if ($stderr){
			$s .= ($tmp = ' ' . $stderr);
			$bg .= $tmp;
		}
		else {
			$s .= $stderr_merge ? ' 2>&1' : '';
			$bg .= ' 2>' . ($stderr_merge ? '&1' : ($as_win ? 'nul' : '/dev/null'));
		}

		//background command - platform format
		if ($as_win){
			if (preg_match($tmp = '/^(start\s*(\/b)?)((?![a-z]).+)$/i', $bg)) $bg = trim(preg_replace('/\s+/', ' ', preg_replace($tmp, '$3', $bg)));
			$bg = 'start /b /separate ' . $bg . ' &';
		}
		else $bg .= ' & echo $!';
		unset($tmp, $q, $quote);
		
		//result
		return [
			'cmd' => $s,
			'cmd_bg' => $bg,
			'stdout' => $stdout,
			'stdout_path' => $stdout_path,
			'stderr' => $stderr,
			'stderr_path' => $stderr_path,
			'stderr_merge' => $stderr_merge ? 1 : 0,
		];
	}

	/**
	 * get process config
	 * 
	 * result [
	 * 		'cmd' => null,				- (string) normalized command line
	 * 		'command' => null,			- (string) proc_open command line
	 * 		'stdout_path' => null,		- (string) parsed command line stdout path
	 * 		'stderr_path' => null,		- (string) parsed command line stderr path
	 * 		'background' => false,		- (bool) command runs in the background
	 * 		'as_win' => null,			- (bool) parsed for windows platform
	 * 		'descriptor_spec' => [],	- (array) options - proc_open file descriptors
	 * 		'cwd' => null,				- (string) options - proc_open working directory
	 * 		'env_vars' => null,			- (array) options - proc_open env_vars
	 * 		'other_options' => null,	- (array) options - proc_open other options
	 * ]
	 * 
	 * @param  string	$cmd		- command line string
	 * @param  array	$options	- process options (proc_open args)
	 * @param  bool		$background	- process runs in the background
	 * @param  bool		$as_win		- parse for windows platform [default: static::is_win()]
	 * @param  string	$error		- ByRef error message
	 * @return array|false			- config data or false on error.
	 */
	public static function config($cmd, $options=null, $background=false, $as_win=null, &$error=null){
		$error = null;

		//parse
		$as_win = is_null($as_win) ? static::is_win() : !!$as_win;
		if (!($parsed = static::parse($cmd, $as_win, $error))) return false;
		if (!($options = static::options($options, $error))) return false;

		//config
		$command = $cmd = $parsed['cmd'];
		$descriptor_spec = $options['descriptor_spec'];
		if ($background = !!$background){
			$command = $parsed['cmd_bg'];
			if ($as_win && count($descriptor_spec)) $descriptor_spec = array_slice($descriptor_spec, 0, 1); //only stdin (windows)
		}

		//result
		return [
			'cmd' => $cmd,
			'command' => $command,
			'stdout_path' => $parsed['stdout_path'],
			'stderr_path' => $parsed['stderr_path'],
			'background' => $background,
			'as_win' => $as_win,
			'descriptor_spec' => $descriptor_spec,
			'cwd' => $options['cwd'],
			'env_vars' => $options['env_vars'],
			'other_options' => $options['other_options'],
		];
	}

	/**
	 * PID validated integer
	 * 
	 * @param  int		$value	- validate PID value
	 * @param  string	$error	- ByRef error message
	 * @return int|false		- PID integer or false on failure
	 */
	public static function pid($value, &$error=null){
		$error = null;
		if (is_numeric($pid = trim($value)) && is_integer($pid = ($pid * 1)) && $pid > 0) return $pid;
		$error = sprintf('Invalid PID value. ([%s] %s)', gettype($value), json_encode($value));
		return false;
	}
	
	/**
	 * pid process child
	 * 
	 * @param  int		$pid	- PID (parent)
	 * @param  array	$pids	- descendant PIDs
	 * @param  string	$error	- ByRef error message
	 * @return int|null			- last descendant PID or false on failure
	 */
	public static function child($pid, &$pids=null, &$error=null){
		$pids = [];
		$error = null;

		//check pid
		if (!($pid = static::pid($pid, $error))) return false;

		//command line
		$is_win = static::is_win();
		if ($is_win) $cmd = sprintf('wmic process get parentprocessid,processid | findstr /i "%s"', $pid);
		else $cmd = sprintf('ps afx --ppid %s', $pid);

		//run command
		$out = null;
		$err = null;
		$exit = null;
		static::_no_verbose(function() use (&$out, &$cmd, &$err, &$exit){
			$out = static::run($cmd, $err, $exit);
		});
		if ($out === false){
			$error = "Pid [$pid] process child exec failure (exit=$exit): $err";
			return false;
		}

		//parse output pids
		$parsed = [];
		if ($out = trim($out)){
			$parsed = explode($is_win ? ' ' : "\n", $out);
			$parsed = array_map(function($val) use (&$is_win, &$cmd){
				if (!$is_win){
					if (strpos($val, $cmd) !== false) return null;
					if (!preg_match('/^\s*([0-9]+)\s*/', $val, $val)) return null;
					$val = $val[1];
				}
				else $val = trim($val);
				return $val && is_numeric($val) && ($val = (int) $val) > 0 ? $val : null;
			}, $parsed);
			$parsed = empty($parsed) ? [] : array_filter($parsed, function($val){
				return is_numeric($val) && trim((int) $val) === trim($val);
			});
			$parsed = empty($parsed) ? [] : array_values($parsed);
			if (!empty($parsed)){
			    if (in_array($pid, $parsed)){
			       $seen = 0;
			       $pids = array_filter($parsed, function($val) use (&$pid, &$seen){
    					if ($val === $pid){
    						$seen = 1;
    						return false;
    					}
					    return $seen;
				    });
			    }
				else $pids = $parsed;
				$pids = empty($pids) ? [] : array_values($pids);
			}
		}

		//result
		$result = ($len = count($pids)) ? $pids[$len - 1] : false;
		if (self::$VERBOSE) static::_verbose(sprintf('> static::child(pid=%s, pids=%s) -> (result=%s, parsed=%s, exit=%s) %s', $pid, json_encode($pids), json_encode($result), json_encode($parsed), $exit, "\ncmd=$cmd\nout=$out"), 1);
		if (!$result) $error = "Pid [$pid] process child not found.";
		return $result;
	}

	/**
	 * pid process exists
	 * 
	 * @param  int		$pid	- PID
	 * @param  string	$error	- ByRef error message
	 * @return int|false		- running PID | 0 nonexistent | false on error
	 */
	public static function exists($pid, &$error=null){
		$error = null;

		//check pid
		if (!($pid = static::pid($pid, $error))) return false;

		//command line
		if ($is_win = static::is_win()) $cmd = sprintf('tasklist /FI "PID eq %d" 2>&1', $pid);
		else $cmd = sprintf('ps -p %d -opid=,cmd= 2>&1', $pid);

		//run command
		$out = null;
		$err = null;
		$exit = null;
		static::_no_verbose(function() use (&$out, &$cmd, &$err, &$exit){
			$out = static::run($cmd, $err, $exit);
		});
		if ($out === false){
			$error = "Pid [$pid] process exists exec failure (exit=$exit): $err";
			return false;
		}

		//result
		$result = ($out = trim($out)) && strpos($out, "$pid") !== false ? $pid : 0;
		if (self::$VERBOSE) static::_verbose(sprintf('> static::exists(pid=%s) -> (result=%s, exit=%s) %s', $pid, json_encode($result), $exit, "\nout=" . $out), 1);
		return $result;
	}

	/**
	 * pid process kill
	 * 
	 * @param  int		$pid	- PID
	 * @param  string	$error	- ByRef error message
	 * @return int|false		- status (-1 = nonexistent, 1 = killed) or false on error
	 */
	public static function kill($pid, &$error=null){
		$error = null;

		//check pid
		if (!($pid = static::pid($pid, $error))) return false;

		//command line
		if ($is_win = static::is_win()) $cmd = sprintf('taskkill /F /T /PID %s 2>&1', $pid);
		else $cmd = sprintf('kill -s 9 %s 2>&1', $pid);

		//run command
		if (($out = static::run($cmd, $err, $exit)) === false){
			$error = "Pid [$pid] process kill exec failure (exit=$exit): $err";
			return false;
		}

		//parse output
		$result = null;
		if ($out = trim($out)){
			$result = 1;
			if ($is_win){
				if (stripos($out, 'no tasks') !== false || stripos($out, 'not found') !== false) $result = -1;
			}
			else if (stripos($out, 'no such process') !== false) $result = -1;
		}

		//verify dead
		if (!$result){
			$exists = null;
			static::_no_verbose(function() use (&$exists, &$pid){
				$exists = static::exists($pid);
			});
			if ($exists){
				$error = "Pid [$pid] process kill failed. (still running)";
				return false;
			}
			else $result = -1;
		}

		//result
		if (self::$VERBOSE) static::_verbose(sprintf('> static::kill(pid=%s) -> (result=%s, exit=%s)', $pid, $result, $exit), 1);
		return $result;
	}

	/**
	 * Timedout helper.
	 * 
	 * @param  float  $timeout  - Timeout seconds.
	 * @param  float  $start    - Start time seconds (microtime(1)).
	 * @param  float  $elapsed  - Seconds elapsed (microtime(1) - $start).
	 * @return bool
	 */
	public static function timedout($timeout=null, $start=null, &$elapsed=null){
		$timeout = is_numeric($timeout) && ($timeout = (float) $timeout) >= 0 ? $timeout : 0;
		$start = is_numeric($start) ? (float) $start : 0;
		$elapsed = microtime(1) - $start;
		return $elapsed >= $timeout;
	}

	/**
	 * Search for executable file.
	 * REF: https://github.com/symfony/process/blob/6.1/ExecutableFinder.php
	 * 
	 * @param  string		$name		- The executable name (without the extension) [Throws exception if undefined]
	 * @param  string|null	$default	- The default to return if no executable is found
	 * @param  array		$extraDirs	- Additional dirs to check into
	 * @return mixed					- (string executable file path | $default value)
	 */
	public static function find_exe($name, $default=null, $extraDirs=[]){
		static $suffixes;
		$dirs = [];
		$ps = PATH_SEPARATOR;
		if (!($name = trim($name))) throw new Exception('Undefined find_exe name.');
		if ($tmp = ini_get('open_basedir')){
			$searchPath = array_merge(explode($ps, $tmp), $extraDirs);
			foreach ($searchPath as $path){
				if (@is_dir($path)) $dirs[] = $path;
				elseif (strtolower(basename($path)) === strtolower($name) && @is_executable($path)) return $path;
			}
		}
		else $dirs = array_merge(explode($ps, getenv('PATH') ?: getenv('Path')), $extraDirs);
		$ds = DIRECTORY_SEPARATOR;
		if (!$suffixes){
			$suffixes = [''];
			if ('\\' === $ds){
				$pathExt = getenv('PATHEXT');
				$suffixes = array_merge($pathExt ? explode($ps, $pathExt) : self::EXE_SUFFIXES, $suffixes);
			}
		}
		foreach ($suffixes as $suffix){
			foreach ($dirs as $dir){
				if (@is_file($file = $dir.$ds.$name.strtolower($suffix)) && ('\\' === $ds || @is_executable($file))) return $file;
			}
		}
		return $default;
	}

	/**
	 * Find php executable binary.
	 * REF: https://github.com/symfony/process/blob/6.1/PhpExecutableFinder.php
	 * 
	 * @param  bool		$includeArgs	- Include runtime arguments (prevents cache if enabled)
	 * @return mixed					- (string php executable file path | false on error)
	 */
	public static function find_php($includeArgs=false){
		static $cached_exe;
		if (!$includeArgs && $cached_exe) return $cached_exe;
		$_phpExe = function($exe) use (&$cached_exe, &$includeArgs){
			if (!@is_executable($exe) || @is_dir($exe)) return false;
			if (!$includeArgs) $cached_exe = $exe;
			return $exe;
		};
		if (!static::is_win() && is_executable($php = '/usr/local/bin/php')) return $_phpExe($php);
		$ds = DIRECTORY_SEPARATOR;
		if ($php = getenv('PHP_BINARY')){
			if (!is_executable($php)){
				$command = '\\' === $ds ? 'where' : 'command -v';
				$command .= ' ' . escapeshellarg($php);
				$out = trim(static::run($command));
				if ($php = strtok($out, PHP_EOL)){
					if (!is_executable($php)) return false;
				}
				else return false;
			}
			return $_phpExe($php);
		}
		$args = [];
		if ('phpdbg' === PHP_SAPI) $args[] = '-qrr';
		$args = $includeArgs && $args ? ' '.implode(' ', $args) : '';
		if (($tmp = PHP_BINARY) && in_array(PHP_SAPI, ['cgi-fcgi', 'cli', 'cli-server', 'phpdbg'], true)) return $_phpExe($tmp.$args);
		if ($php = getenv('PHP_PATH')) return $_phpExe($php);
		if (($php = getenv('PHP_PEAR_PHP_BIN')) && @is_executable($php) && !@is_dir($php)) return $_phpExe($php);
		$bin_dir = PHP_BINDIR;
		if (@is_executable($php = $bin_dir.('\\' === $ds ? '\\php.exe' : '/php')) && !@is_dir($php)) return $_phpExe($php);
		$dirs = [$bin_dir];
		if ('\\' === $ds) $dirs[] = 'C:\xampp\php\\';
		return $_phpExe(static::find_exe('php', false, $dirs));
	}
	
	/**
	 * Poll callback helper.
	 * 
	 * @param  callable $poll_callback	- Polling callback (this should return truthy value to abort polling)
	 * @param  int		$sleep_ms		- Polling interval sleep microseconds [default 1000 (1 sec)] (minimum 100)
	 * @param  int		$timeout		- Polling timeout seconds. [default 10 sec] (0 = unlimited)
	 * @param  string	$error			- ByRef Polling error message
	 * @return bool						- Polling complete (false on error)
	 */
	public static function poll($poll_callback=null, $sleep_ms=1000, $timeout=10, &$error=null){
		$error = null;
		try {
			if (!is_callable($poll_callback)) throw new Exception('Polling callback is not callable.');
			$sleep_ms = is_integer($sleep_ms) && $sleep_ms >= 100 ? $sleep_ms : 1000;
			$timeout = is_integer($timeout) && $timeout >= 0 ? $timeout : 10;
			$start = microtime(1);
			while (true){
				if (call_user_func($poll_callback)) return true;
				if ($timeout && static::timedout($timeout, $start, $eta)) throw new Exception('Polling timed out.');
				usleep($sleep_ms * 1000);
			}
		}
		catch (Exception $e){
			$error = $e -> getMessage();
			return false;
		}
	}

	/**
	 * Poll process exists status.
	 * 
	 * @param  int		$pid			- Process PID
	 * @param  bool		$exists			- Poll check if PID process is running if enabled otherwise checks not running
	 * @param  callable $poll_callback	- Poll callback method called after failed check (aborts polling if callback returns truthy value)
	 * @param  int		$sleep_ms		- Polling interval sleep microseconds [default 1000 (1 sec)] (minimum 100)
	 * @param  int		$timeout		- Polling timeout seconds. [default 10 sec] (0 = unlimited)
	 * @param  string	$error			- ByRef Polling error message
	 * @return bool						- Polling complete (false on error)
	 */
	public static function poll_exists($pid, $exists=true, $poll_callback=null, $sleep_ms=1000, $timeout=10, &$error=null){
		$error = null;
		if (!($pid = static::pid($pid, $error))) return false;
		$poll_callback = is_callable($poll_callback) ? $poll_callback : null;
		return static::poll(function() use (&$pid, &$exists, &$poll_callback){
			$pid_exists = null;
			static::_no_verbose(function() use (&$pid_exists, &$pid){
				$pid_exists = static::exists($pid);
			});
			if (!!$pid_exists === !!$exists) return true;
			if ($poll_callback && call_user_func($poll_callback)) return true;
		}, $sleep_ms, $timeout, $error);
	}

	/**
	 * set no execution limit
	 * 
	 * ~ usage: $_restore = static::no_limit();
	 * ~ restore: $_restore();
	 * 
	 * @param  int	$ignore_abort	- ByRef previous value ignore_user_abort()
	 * @param  int	$max_time		- ByRef previous value max_execution_time
	 * @return Closure  - call to restore previous values
	 */
	public static function no_limit(&$ignore_abort=null, &$max_time=null){
		$ignore_abort = (int) ignore_user_abort();
		$max_time = (int) ini_get('max_execution_time');
		set_time_limit(0);
		ignore_user_abort(1);
		return function() use (&$ignore_abort, &$max_time){
			ignore_user_abort($ignore_abort);
			set_time_limit($max_time);
		};
	}

	/**
	 * output buffer end
	 * 
	 * @param  bool  $clean	- use method - ob_end_clean() if enabled [default: ob_end_flush()]
	 * @return bool			- method success
	 */
	public static function print_end($clean=false){
		$res = true;
		while (ob_get_level() && ($res = $clean ? ob_end_clean() : ob_end_flush()));
		return $res;
	}

	/**
	 * output buffer restart (end previous buffer if any - ob_start())
	 * 
	 * @param  bool  $clean	- ob_end_clean() if enabled [default: ob_end_flush()]
	 * @return bool			- ob_start() success
	 */
	public static function print_start($clean=false){
		static::print_end($clean);
		$res = true;
		if (!ob_get_level()) $res = ob_start();
		return $res;
	}

	/**
	 * print output
	 * 
	 * @param  string	$value	- print value.
	 * @param  bool		$br		- enable line break.
	 * @param  string	$str	- ByRef stringified print value (without buffer padding or line break)
	 * @return string			- output buffer
	 */
	public static function print_out($value, $br=true, &$str=null){
		
		//to string
		if (is_null($value) || is_bool($value) || is_object($value)) $value = json_encode($value);
		elseif (is_array($value)){
			$_arr_val = function($arr) use (&$_arr_val){
				$tmp = [];
				foreach ($arr as $key => $val){
					if (is_null($val) || is_bool($val) || is_object($val)) $val = json_encode($val);
					elseif (is_array($val)) $val = $_arr_val($val);
					$tmp[$key] = $val;
				}
				return $tmp;
			};
			$value = print_r($_arr_val($value), 1);
		}
		
		//string pad, break
		$str = $value;
		$reg = '/\r?\n[\t ]*$/s';
		$reg_match = preg_match($reg, $value, $matches);
		$pad_str = !static::is_win();
		if ($pad_str){
			$pad_size = 4096;
			$append = '';
			if ($reg_match){
				$pad_size -= strlen($append = $matches[0]);
				$value = preg_replace($reg, '', $value);
			}
			$value = str_pad($value, $pad_size, ' ', STR_PAD_RIGHT) . $append;
		}
		if ($br && !$reg_match) $value .= "\n";

		//print
		echo $value;
		ob_flush();
		flush();

		//result - buffer
		return $value;
	}

	/**
	 * read pipe resource buffer
	 * 
	 * @param  resource	$pipe				- resource pipe
	 * @param  bool		$print				- buffer print
	 * @param  array	$buffer_callback	- buffer callback [return false to abort read] (i.e. function(string $buffer){...})
	 * @param  string	$error				- ByRef error message
	 * @param  int		$abort				- ByRef abort status (0=no abort, 1=callback abort, 2=connection abort)
	 * @return string|false					- read contents or false on error
	 */
	public static function read_pipe($pipe, $print=false, $buffer_callback=null, &$error=null, &$abort=null){
		$error = null;
		$abort = 0;

		//check pipe
		if (!is_resource($pipe)){
			$error = 'Pipe resource is invalid.';
			return false;
		}

		//init
		$output = '';
		$read_size = 4096; //DEBUG: 1024
		$buffer_callback = is_callable($buffer_callback) ? $buffer_callback : null;
		$_restore = static::no_limit($ignore_abort);
		if ($print) static::print_start();
		
		//read loop
		while (!feof($pipe)){
			
			//read
			$buffer = fgets($pipe, $read_size);

			//buffer
			if (strlen($buffer)){
				
				//print
				if ($print) static::print_out($buffer, $_br=false, $buffer);
				
				//output
				$output .= $buffer;
				
				//callback
				if ($buffer_callback){
					try {
						if (call_user_func_array($buffer_callback, [$buffer]) === false){
							$abort = 1;
							break;
						}
					}
					catch (Exception $e){
						$_restore();
						$error = 'Read pipe callback failure: ' . $e -> getMessage();
						return false;
					}
				}

				//abort
				if (connection_aborted() && !$ignore_abort){
					$abort = 2;
					break;
				}
			}
		}

		//done - result
		$_restore();
		return $output;
	}

	/**
	 * read file resource buffer
	 * 
	 * @param  string	$path				- file path string
	 * @param  int		$pid				- related process Id (on read failure (eof), waits and retries read while process is still running)
	 * @param  int		$seek				- file read initial seek position [default=0]
	 * @param  bool		$print				- buffer print
	 * @param  array	$buffer_callback	- buffer callback [return false to abort read] (i.e. function(string $buffer){...})
	 * @param  string	$error				- ByRef error message
	 * @param  int		$abort				- ByRef abort status (0=no abort, 1=callback abort, 2=connection abort)
	 * @return string|false					- read contents or false on error
	 */
	public static function read_file($path, $pid=null, $seek=0, $print=false, $buffer_callback=null, &$error=null, &$abort=null){
		$error = null;
		$abort = 0;
		
		//check path
		if (!is_file($path)){
			$error = "File resource does not exist. ($path)";
			return false;
		}

		//init
		$output = '';
		$read_size = 4096; //DEBUG: 1024 * 8 (4096 * 2)
		$buffer_callback = is_callable($buffer_callback) ? $buffer_callback : null;
		$pid = is_numeric($pid) && ($pid = (int) $pid) >= 1 ? $pid : null;
		$seek = is_numeric($seek) && ($seek = (int) $seek) >= 0 ? $seek : 0;
		$_restore = static::no_limit($ignore_abort);
		if ($print) static::print_start();

		//try loop
		$stop = 0;
		$exists = 1;
		while (1){

			//open
			if (!is_file($path)) break;
			$pipe = @fopen($path, 'rb');
			if (!is_resource($pipe)) break;

			//stop reset
			if ($stop){
				if (($stat = fstat($pipe)) === false){
					$_restore();
					$error = "File resource fstat failure. ($path)";
					return false;
				}
				if ($stat['size'] > $seek) $stop = 1;
			}

			//seek
			if (fseek($pipe, $seek) < 0){
				$_restore();
				$error = "File resource fseek [$seek] failure. ($path)";
				return false;
			}

			//read loop
			while (!feof($pipe)){
				
				//read
				$buffer = fread($pipe, $read_size);

				//update seek
				if (($seek = ftell($pipe)) === false){
					$_restore();
					$error = "File resource ftell failure. ($path)";
					return false;
				}

				//buffer
				if (strlen($buffer)){

					//print
					if ($print) static::print_out($buffer, $_br=false, $buffer);

					//output
					$output .= $buffer;

					//callback
					if ($buffer_callback){
						try {
							if (call_user_func_array($buffer_callback, [$buffer]) === false){
								$abort = 1;
								break;
							}
						}
						catch (Exception $e){
							$_restore();
							$error = 'Read file callback failure: ' . $e -> getMessage();
							return false;
						}
					}

					//abort
					if (connection_aborted() && !$ignore_abort){
						$abort = 2;
						break;
					}
				}
			}

			//close
			fclose($pipe);

			//check stop/retry
			if (!$abort && $pid){
				if (!$stop) static::_no_verbose(function() use (&$exists, &$pid){
					$exists = static::exists($pid);
				});
				if (!$exists){
					$stop ++;
					if ($stop < 3){
						if ($stop > 1) usleep(500 * 1000);
						continue;
					}
				}
				else continue;
			}

			//break
			break;
		}

		//done
		$_restore();

		//result
		return $output;
	}

	/**
	 * run inline command - proc_open simple implementation
	 * 
	 * @param  string	$cmd				- Command line string
	 * @param  string	$error				- ByRef error message
	 * @param  int		$exit				- ByRef process exit code
	 * @param  array	$options			- process options (see static::options())
	 * @param  bool		$print				- buffer print
	 * @param  array	$buffer_callback	- buffer callback [return false to abort read] (i.e. function(string $buffer){...})
	 * @param  resource	$resource			- buffer read resource pipe/path [default: $proc -> pipe(1)]
	 * @param  int		$abort				- ByRef buffer abort status (0=no abort, 1=callback abort, 2=connection abort)
	 * @return string|false					- buffer output string or false on error
	 */
	public static function run($cmd, &$error=null, &$exit=null, $options=null, $print=false, $buffer_callback=null, $resource=null, &$abort=null){
		$error = null;
		$exit = null;
		$abort = null;
		$output = '';

		//open process
		$proc = new static($cmd, $options, false);
		$opened = $proc -> open(function($p) use (&$output, &$print, &$buffer_callback, &$resource, &$error, &$abort){
			$p -> close_pipe(0);
			$output = $p -> output($print, $buffer_callback, $resource, $error, $abort);
			if ($output === false) return false;
		});
		
		//close process
		$proc -> close();
		$exit = $proc -> exit;
		
		//failure
		if ($opened === false && !$error){
			$error = $proc -> error;
			$output = false;
		}

		//result
		if (self::$VERBOSE) static::_verbose(sprintf("> static::run(%s) (pid=%s, exit=%s, error=%s, abort=%s)\n%s", $cmd, $proc -> pid, $exit, $error, $abort, is_string($output) ? $output : json_encode($output)), 2);
		return $output;
	}

	/**
	 * Open background process helper.
	 * 
	 * @param  string	$cmd			- Command line (constructor argument 1)
	 * @param  string	$error			- ByRef failure error message
	 * @param  array	$options		- process options (see static::options())
	 * @param  callable	$open_callback	- Process -> open() callback method (i.e. function(Process $arg){})
	 * @param  string	$pid_file		- Background process PID cache file path
	 * @param  bool		$resume			- Enable background process resume if cached PID is still running
	 * @param  int		$resumed		- ByRef resumed status (1 = process was resumed, 0 = new process, null = failure)
	 * @return int|false				- Background process PID or false on Process -> open() failure.
	 */
	public static function run_bg($cmd, &$error=null, $options=null, $open_callback=null, $pid_file=null, $resume=true, &$resumed=null){
		$file = null;
		$error = null;
		$resumed = 0;

		//check cached pid process - resume running
		if (is_string($pid_file) && ($pid_file = trim($pid_file))) $file = $pid_file;
		if ($resume && is_file($file) && ($pid = file_get_contents($file)) !== false){
			$exists = null;
			static::_no_verbose(function() use (&$exists, &$pid){
				$exists = static::exists($pid);
			});
			if ($exists){
				$resumed = 1;
				return $pid;
			}
		}

		//open background process
		$proc = new static($cmd, $options, true);
		if (!$proc -> open($open_callback)){
			$error = $proc -> error;
			return false;
		}

		//close parent
		$proc -> close();

		//cache pid
		$pid = $proc -> pid;
		if ($file && !file_put_contents($file, "$pid")){
			$error = "Process run cache PID failure! ($file)";
			$proc -> close(1);
			return false;
		}

		//result
		return $pid;
	}
}

#================================  _funcs   =================================

//get option
function _option($key=null, $value='!undefined'){
	if (!(isset($GLOBALS['__options__']) && is_array($GLOBALS['__options__']))) return _failure('Undefined $GLOBALS[__options__] array.');
	if (empty($key)) return $value === '!undefined' ? $GLOBALS['__options__'] : _failure('Undefined $GLOBALS[__options__] key.');
	if ($value !== '!undefined') $GLOBALS['__options__'][$key] = $value;
	return array_key_exists($key, $GLOBALS['__options__']) ? $GLOBALS['__options__'][$key] : null;
}

//header
function _header($value){
	static $header_set;
	if ($header_set) return;
	$header_set = 1;
	header($value);
}

//request url
function _request_url(){
	if (!(
		isset($_SERVER)
		&& is_array($_SERVER)
		&& array_key_exists($key = 'HTTP_HOST', $_SERVER)
		&& ($host = trim($_SERVER[$key]))
		&& array_key_exists($key = 'REQUEST_URI', $_SERVER)
		&& is_string($request_uri = $_SERVER[$key])
	)) return false;
	if ($query_string = array_key_exists($key = 'QUERY_STRING', $_SERVER) ? trim($_SERVER[$key]) : null){
		$request_uri = trim(str_replace($query_string, '', $request_uri), '? ');
	}
	$protocol = 'http' . (array_key_exists($key = 'HTTPS', $_SERVER) && trim($_SERVER[$key]) ? 's' : '') . '://';
	return $protocol . $host . '/' . trim($request_uri, '/');
}

//redirect
function _redirect(){
	if (!($url = _request_url())) return _failure('Unable to get the request/redirect url.');
	_header("Location: $url");
}

//echo/print
function _echo($value, $br=1, $exit_status=null){
	static $print_start;
	
	//print start
	if (!$print_start){
		$print_start = 1;
		_header('Content-type: text/plain');
		Process::print_start();
	}

	//print out
	Process::print_out($value, $br, $str);
	if (_option('worker')) _write(_option('log_file'), trim($str) . "\n", 1); //FIX: DEBUG:
	if (is_integer($exit_status)) exit($exit_status);
}

//failure
function _failure($error){
	if (_option('worker')) throw new Exception($error);
	_write(_option('err_file'), trim($error) . "\n", 1);
	_echo("FAILURE: $error", 1, 1);
}

//read
function _read($path, $assoc=0){
	if (($data = file_get_contents($path)) === false) return _failure("unable to read ($path)");
	if ($assoc && !is_array($data = json_decode($data, 1))) return _failure("invalid assoc data ($path)");
	return $data;
}

//write
function _write($path, $data, $append=0, &$bytes=null){
	$bytes = null;
	$data = is_array($data) || is_object($data) ? json_encode($data) : (string) $data;
	if (($res = @file_put_contents($path, $data, $append ? FILE_APPEND : 0)) === false) return _failure("unable write ($path)");
	$bytes = $res;
	return true;
}

//delete
function _delete($path, $fails=1){
	if (!is_file($path)) return -1;
	if (!@unlink($path)) return $fails ? _failure("unable delete ($path)") : false;
	return true;
}

//cleanup
function _cleanup($fails=0){
	_delete(_option('tmp_file'), $fails);
	_delete(_option('log_file'), $fails === 1);
	_delete(_option('pid_file'), $fails);
}

//cache data
function _cache_data($data){
	if (!(
		is_array($data)
		&& isset($data[$key = 'cmd'])
		&& ($cmd = trim($data[$key]))
		&& isset($data[$key = 'pid'])
		&& ($pid = Process::pid($data[$key]))
	)) return false;
	$type = isset($data[$key = 'type']) && in_array($val = trim(strtolower($data[$key])), ['process', 'worker']) ? $val : 'process';
	$expires = isset($data[$key = 'expires']) && is_integer($val = $data[$key]) && $val >= 0 ? $val : 0;
	$child_cmd = isset($data[$key = 'child_cmd']) && ($val = trim($data[$key])) ? $val : null;
	$child_pid = isset($data[$key = 'child_pid']) && ($val = Process::pid($data[$key])) ? $val : null;
	return [
		'cmd' => $cmd,
		'pid' => $pid,
		'type' => $type,
		'expires' => $expires,
		'child_cmd' => $child_cmd,
		'child_pid' => $child_pid,
	];
}

//cache set
function _cache_set($data){
	if (!($data = _cache_data($data))) return _failure('Invalid cache data.');
	_write(_option('tmp_file'), $data);
	return $data;
}

//cache get
function _cache_get($running=0, $kill=0){
	if (!is_file($path = _option('tmp_file'))) return;
	if (!($data = _cache_data(_read($path, 1)))) return _failure("Invalid cache file data contents. ($path)");
	$is_worker = $data['type'] === 'worker';
	$is_running = 0;
	if ($is_worker){
		if (time() < $data['expires']){
			if ($pid = $data['child_pid']){
				if ($res = Process::exists($pid, $err)) $is_running = $res;
				if ($res === false) return _failure($err);
			}
			else $is_running = -1;
		}
	}
	else {
		if ($res = Process::exists($data['pid'], $err)) $is_running = $res;
		if ($res === false) return _failure($err);
	}
	if ($is_running){
		if ($kill){
			if ($is_running >= 1) _kill_pid($is_running);
			else _kill_pid($data['pid']);
			usleep(200 * 1000); //delay 200ms
		}
		else return $data;
	}
	_cleanup(2);
	if (!$running) return $data;
}

//kill pid
function _kill_pid($pid){
	if (!(is_integer($pid) && $pid >= 1)) return;
	if (($res = Process::kill($pid, $error)) === false) return _failure($error);
	return $res;
}

//buffer running
function _buffer_running($data=null){
	$is_cache = !!($data = _cache_data($data));
	if (!$is_cache && !($data = _cache_get())) return;

	//opened/resumed process
	$cmd = $data['cmd'];
	$pid = $data['pid'];
	if ($data['type'] === 'worker'){
		$cmd = sprintf('[%s] %s - (%s)', $pid, $cmd, $data['child_cmd']);
		$pid = $data['child_pid'];
	}
	if (!$is_cache) _echo("[resume: $pid]> $cmd");

	//output buffer
	$_restore = Process::no_limit();
	try {
		$abort = 0;
		if (is_file($path = _option('log_file'))){
			$res = Process::read_file($path, $pid, $_seek=0, $_print=true, $_callback=null, $error, $abort);
			if ($abort) _echo("Buffer abort: $abort");
			if ($res === false) throw new Exception("Buffer Error: $error");
			else _cache_get(1);
		}
		else {
			_echo("[$pid]> process output log file not found - polling...");
			$res = Process::poll_exists($pid, false, function() use (&$pid, &$abort) {
				if (connection_aborted()){
					$abort = 2;
					return true;
				}
				_echo("- [$pid] is running.");
			}, $_sleep_ms=1000, $timeout=null, $error);
			if ($abort) _echo("Buffer abort: $abort");
			if (!$res) throw new Exception("Polling Error: $error");
			if (!$abort) _echo("[$pid] done.", 1, 0);
		}
		$_restore();
		if ($abort) return false;
	}
	catch (Exception $e){
		$_restore();
		return _failure($e -> getMessage());
	}
}

//command line
function _command($cmd, $stdout=0){
	static $php;
	
	//check cmd
	if (!(is_string($cmd) && ($cmd = trim($cmd)))) return _failure('Empty command line.');
	
	//php executable
	if (!$php){
		$php = Process::find_php();
		if (strpos($php, ' ') !== false) $php = '"' . $php . "'";
	}

	//show php executable
	if (strtolower($cmd) === 'php') return _echo("$cmd -> $php\n", 1, 0);
	
	//parse cmd - check stdout, stderr
	if (strpos($cmd, '>') !== false){
		$parse = Process::parse($cmd);
		if (isset($parse['stdout']) && trim($parse['stdout'])) return _failure("command stdout pipe not supported. ($cmd)");
		if (isset($parse['stderr']) && trim($parse['stderr'])) return _failure("command stderr pipe not supported. ($cmd)");
	}

	//normalize
	if (stripos($cmd, 'php self') === 0){
		$file = _option('target');
		if (strpos($file, ' ') !== false) $file = '"' . $file . '"';
		$cmd = preg_replace('/^php self\s+/i', "$php $file ", $cmd);
	}
	elseif (stripos($cmd, 'php') === 0) $cmd = preg_replace('/^php\s+/i', "$php ", $cmd);
	elseif (stripos($cmd, 'composer') === 0){
	    if (strtolower($cmd) === 'composer') $cmd = "$php composer";
		else $cmd = preg_replace('/^composer\s+/i', "$php composer ", $cmd);
	}

	//stdout log
	if ($stdout) $cmd .= ($stdout === 2 ? ' >> ' : ' > ') . _option('stdout');
	$cmd .= ' 2>&1';
	
	//result
	return $cmd;
}

//run background process
function _run($cmd, $cached=0){
	$pid_file = $cached ? _option('pid_file') : null;
	/*
	$proc = new Process($cmd, ['cwd' => _option('cwd')], 1);
	if (!$proc -> open(function($p){
	    $p -> close_pipe(0);
	})) return _failure("Run Error: " . $proc -> error);
	if (!($pid = Process::pid($proc -> pid, $err))){
	    $proc -> close(1);
	    return _failure("Run PID Error: $err");
	}
	$GLOBALS['__proc__'] = $proc;
	if ($pid_file) _write($pid_file, "$pid");
	sleep(1);
	//*/
	/*
	$pid = Process::run_bg($cmd, $error, ['cwd' => _option('cwd')], $cb=null, $pid_file);
	if (!$pid) return _failure("Run Error: $error");
	//*/
	putenv('COMPOSER_HOME=' . _option('cwd') . '/vendor/bin/composer');
	$cmd .= ' & echo $!';
	$out = shell_exec($cmd);
	if (!($pid = Process::pid((int) trim($out), $err))) return _failure("Shell exec failed: $err ($cmd)");
	$res = Process::exists($pid);
	//DEBUG: _echo("[$pid] started...");
	return [
		'cmd' => $cmd,
		'pid' => $pid
	];
}

//run resume
function _run_resume(){
	$res = _buffer_running();
	if ($data = _cache_get(1)) return _failure(sprintf('Previous %s is still running. [%s] (%s)', $data['type'], $data['pid'], $data['cmd']));
}

//run cached process
function _run_cached($cmd){
	_run_resume();
	$cmd = _command($cmd, 1);
	//DEBUG: _echo(">> $cmd");
	$data = _run($cmd, 1);
	$data = _cache_set($data);
	$res = _buffer_running($data);
	if ($res !== false) _run(_command('php self clear')); //auto cleanup
	return $res;
}

//worker cache
function _worker_set($data){
	$data = is_array($data) ? $data : [];

	//new cache data
	if (!($worker = _cache_data(_option('worker')))){
		if (!(array_key_exists($key = 'cmd', $data) && ($cmd = trim($data[$key])))){
			return _failure('Undefined worker data cmd.');
		}
		$worker = [
			'cmd' => $cmd,
			'pid' => _option('mypid'),
			'type' => 'worker',
			'expires' => time() + 5, //5 sec
			'child_cmd' => null,
			'child_pid' => null,
		];
	}

	//update cache data
	if (array_key_exists($key = 'expires', $data)) $worker[$key] = $data[$key];
	if (array_key_exists($key = 'child_cmd', $data)) $worker[$key] = $data[$key];
	if (array_key_exists($key = 'child_pid', $data)) $worker[$key] = $data[$key];
	
	//save
	return _option('worker', _cache_set($worker));
}

//worker
function _worker($cmd, $handler){
	if (!is_callable($handler)) return _failure('Worker handler is not callable.');
	_run_resume();
	_echo(">>> $cmd...");
	_worker_set(['cmd' => $cmd]);
	$_restore = Process::no_limit();
	$_done = function() use (&$_restore, &$cmd){
		$_restore();
		//_cleanup(2);
		_option('worker', null);
		_echo(">>> $cmd done.");
	};
	try {
		$handler();
		$_done();
	}
	catch (Exception $e){
		$_done();
		return _failure($e -> getMessage());
	}
}

//worker install composer
function _worker_install_composer(){
	_worker('install-composer', function(){
		$ts = microtime(1);
		
		//copy helper
		$_copy = function ($source, $dest){
			$tmp = basename($dest);
			_echo("\nCopy: $source -> $tmp");
			if (copy($source, $dest)) return true;
			return _failure("Unable to copy ($source -> $dest)");
		};
		
		//composer files
		$cwd = _option('cwd');
		$sig_file = $cwd . '/composer.sig';
		$setup_file = $cwd . '/composer-setup.php';
		$phar_file = $cwd . '/composer.phar';
		$composer_file = $cwd . '/composer';
		
		//get signature
		$_copy('https://composer.github.io/installer.sig', $sig_file);
		$sig = trim(_read($sig_file));
		_delete($sig_file);
		_echo("Signature: $sig");
	
		//get setup
		$setup_file = _option('cwd') . '/composer-setup.php';
		$_copy('https://getcomposer.org/installer', $setup_file);
		if (hash_file('sha384', $setup_file) !== $sig){
			_delete($setup_file);
			$eta = time() - $ts;
			return _failure("Installer corrupt - deleted. ($eta sec)\n");
		}
		$eta = microtime(1) - $ts;
		_echo("Installer verified. ($eta sec)");
		
		//run setup
		$ts = microtime(1);
		_echo("\nSetup composer...");
		_delete($phar_file);
		$cmd = _command('php composer-setup.php', 2);
		/*
		_echo("exec>> $cmd");
		$res = exec($cmd . ' & echo $!', $output, $exit);
		_echo(['output' => $output, 'exit' => $exit]);
		if ($res === false) return _failure('Exec failed.');
		*/
		///*
		$data = _run($cmd, 1);
		$res = _buffer_running(_worker_set([
			'expires' => time() + 5,
			'child_cmd' => $data['cmd'],
			'child_pid' => $data['pid'],
		]));
		$eta = microtime(1) - $ts;
		if ($res === false){
			_kill_pid($data['pid']);
			return _failure("Setup composer interrupted. ($eta sec)");
		}
		//*/
		_echo("Setup done. ($eta sec)");

		//finalizing
		_worker_set([
			'expires' => 0,
			'child_cmd' => null,
			'child_pid' => null,
		]);
		$ts = microtime(1);
		_echo('Finalizing composer installation...');
		if (!is_file($phar_file)) return _failure("Installed file not found. ($phar_file)");
		_delete($setup_file);
		_delete($composer_file);
		if (!rename($phar_file, $composer_file)) return _failure("Rename failed. ($phar_file > $composer_file)");
		$eta = microtime(1) - $ts;
		_echo("Installed: $composer_file ($eta sec)", 1, 0);
	});
}

//test lines
function _test_lines(){
	$max = 50;
	$ms = 200;
	_echo("Test $max lines (sleep $ms ms)...");
	for ($i = 1; $i <= $max; $i ++){
		_echo("[$i/$max] - test line.");
		usleep($ms * 1000);
	}
	_echo('Test lines done.');
}

//test requirements
function _test_requirements(){
	
	//init vars
	$errors = [];
	$fails = 0;
	$sp = ($is_console = Process::is_console()) ? '  ' : ' ';
	$pass = '' . $sp;
	$fail = '' . $sp;

	//print helper
	$_msg = function($str, $p=null) use (&$pass, &$fail, &$fails, &$errors){
		if (!is_null($p) && !$p){
			$fails += 1;
			$errors[] = $str;
		}
		_echo(sprintf('%s%s', is_null($p) ? '' : ($p ? $pass : $fail), $str));
	};

	//test
	_echo("Testing Requirements... (is_console=$is_console)");
	_echo('');

	//Test PHP Version >= 7.3
	$c = '7.3';
	$v = PHP_VERSION;
	if (!version_compare($v, $c, '>=')) $_msg("Error PHP Version ($v < $c).", 0);
	else $_msg("PHP Version ($v >= $c)", 1);
	
	//Test Extensions
	$required_exts = [
		'bcmath' => 'BCMath PHP Extension',
		'ctype' => 'Ctype PHP Extension',
		'fileinfo' => 'Fileinfo PHP Extension',
		'json' => 'JSON PHP Extension',
		'mbstring' => 'Mbstring PHP Extension',
		'openssl' => 'OpenSSL PHP Extension',
		'PDO' => 'PDO PHP Extension',
		'tokenizer' => 'Tokenizer PHP Extension',
		'xml' => 'XML PHP Extension',
		'gd' => 'GD PHP Extension',
	];

	//check loaded extension
	$loaded_exts = get_loaded_extensions();
	foreach ($required_exts as $ext => $title){
		if (!in_array($ext, $loaded_exts)) $_msg("Error $title ($ext) Not Loaded.", 0);
		else $_msg("Loaded $title ($ext)", 1);
	}

	//result
	$status = !$fails ? 'PASSED' : "FAILED ($fails)";
	_echo('');
	_echo("Test $status");
}

#================================  _html    =================================
?>

<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="google" content="notranslate">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title><?php echo _option('title'); ?></title>
	<script type="text/javascript">
		window.CONFIG = <?php echo json_encode(['resume' => _option('resume')]); ?>;
	</script>
	<style>
		.container {
			min-width: 70%;
		}
		@media only screen and (max-width: 768px){
			.container {
				min-width: 90%;
			}
		}
		.input {
			margin: 0;
			color: teal;
			outline: none;
			flex-grow: 1;
			border: 1px solid #ddd;
			padding: 4px 8px;
			font-size: 14px;
			font-weight: bold;
			font-family: 'monospace', consolas;
		}
		.label {
			width: 50px;
			color: #555;
			font-size: 14px;
			font-weight: bold;
			cursor: pointer;
		}
		.btn {
			padding: 4px 8px;
			min-width: 100px;
		}
	</style>
</head>
<body style="position:fixed;top:0;left:0;width:100%;height:100%;margin:0;font-family:'monospace',consolas;background-color:#eee;">
	<div style="position:relative;width:100%;height:100%;display:flex;flex-direction:column;">
		<div class="container" style="flex-grow:1;display:flex;flex-direction:column;background:#fff;border:1px solid #ddd;margin:20px auto;">
			
			<!-- head -->
			<div style="padding:10px;text-align:center;">
				<h2 style="margin:0;font-size:16px;color:#888"><?php echo _option('title'); ?></h2>
			</div>
			
			<!-- output -->
			<div style="position:relative;flex-grow:1;">
				<div id="output_wrapper" style="display:flex;flex-direction:column;overflow:scroll;position:absolute;top:0;left:0;width:100%;height:100%;">
					<div id="output" style="flex-grow:1;background:#000;color:#9f9;padding:10px;white-space:pre-wrap;font-size:12px;"></div>
				</div>
			</div>
			
			<!-- form -->
			<form id="cmd_form" action="" method="post" style="font-size:12px;display:flex;flex-direction:column;">
				
				<!-- inputs -->	
				<div style="padding:10px;display:flex;flex-direction:column;gap:4px">
					<div style="display:flex;flex-direction:row;align-items:center;">
						<label for="input_cmd" class="label" title="Type command here">CMD:</label>
						<input id="input_cmd" class="input" style="color:blue;" type="text" value="" />
					</div>
					<div style="display:flex;flex-direction:row;align-items:center;">
						<label for="input_cwd" class="label" title="Working directory">CWD:</label>
						<input id="input_cwd" class="input" type="text" readonly="readonly" value="<?php echo _option('cwd'); ?>" />
					</div>
				</div>

				<!-- buttons -->
				<div style="padding:10px;gap:10px;display:flex;flex-direction:row;flex-wrap:wrap;border-top:1px solid #ddd;justify-content:start;">
					<button id="btn_requirements" class="btn" type="button" title="Test Requirements">Test Requirements</button>
					<button id="btn_install_composer" class="btn" type="button" title="Install Composer">Install Composer</button>
					<button id="btn_clear" class="btn" type="button" title="Clear Output">Clear</button>
					<button id="btn_cancel" class="btn" type="button" title="Cancel Running">Cancel</button>
					<div style="flex-grow:1;display:inline-flex;flex-direction:row;justify-content:end;">
						<button id="btn_run" class="btn" type="submit" title="Run Command">Run</button>
					</div>
				</div>
			</form>
		</div>
	</div>
	<script type="text/javascript">
		let IS_CANCELLED, IS_DISABLED, ENDPOINT = window.location.href, RESUME = window.CONFIG?.resume;
		
		//output wrapper - scroll
		const output_wrapper = document.getElementById('output_wrapper');
		let output_scroll_ignore = 0;
		output_wrapper.addEventListener('scroll', () => {
			if (output_scroll_ignore === 1) return output_scroll_ignore = 0;
			output_scroll_ignore = 2;
			const el = output_wrapper, offset = 20;
			if (el.scrollHeight < el.offsetHeight || (el.scrollHeight - el.scrollTop - el.offsetHeight) < offset) output_scroll_ignore = 0;
		}, {passive: true});
		const outputScrollBottom = () => {
			if (output_scroll_ignore > 1 || output_wrapper.scrollHeight < output_wrapper.scrollHeight) return;
			output_scroll_ignore = 1;
			output_wrapper.scrollTop = output_wrapper.scrollHeight;
		};

		//output - text
		const output = document.getElementById('output');
		const output_prompt = '>_';
		const outputClear = text => output.innerText = output_prompt;
		const outputText = text => {
			output.innerText = output.innerText.replace(new RegExp(`\n?${output_prompt}\s*$`, 'g'), '') + String(text);
			outputScrollBottom();
		};
		const outputPrompt = () => {
			output.innerText = output.innerText.trim() + '\n\n' + output_prompt;
			outputScrollBottom();
		};
		const outputCmd = cmd => outputText((output.innerText.indexOf('\n') > -1 ? '\n' : '') + '> ' + cmd + '\n');

		//controls
		const cmd_form = document.getElementById('cmd_form');
		const input_cmd = document.getElementById('input_cmd');
		const btn_requirements = document.getElementById('btn_requirements');
		const btn_install_composer = document.getElementById('btn_install_composer');
		const btn_clear = document.getElementById('btn_clear');
		const btn_run = document.getElementById('btn_run');
		const btn_cancel = document.getElementById('btn_cancel');

		//disabled
		const setDisabled = (disabled=true, cancel) => {
			IS_DISABLED = disabled = !!disabled;
			cancel = cancel === undefined ? !disabled : !!cancel;
			[btn_requirements, btn_install_composer, btn_clear, btn_run].forEach(element => {
				if (disabled) element.setAttribute('disabled', 'disabled');
				else element.removeAttribute('disabled');
			});
			if (cancel) btn_cancel.setAttribute('disabled', 'disabled');
			else btn_cancel.removeAttribute('disabled');
			if (disabled) input_cmd.setAttribute('readonly', 'readonly');
			else input_cmd.removeAttribute('readonly');
		};
		const isDisabled = () => {
			if (IS_DISABLED){
				console.warn('Controls are disabled.');
				return true;
			}
			return false;
		};

		//fetch request
		const fetchRequest = async (url, options, onRead) => {
			let RESPONSE, RESPONSE_DATA;
			onRead = 'function' === typeof onRead ? onRead : undefined;
			return window.fetch(url, options).then(async res => {
				RESPONSE = res.clone();
				const decoder = new TextDecoder();
				const reader = res.body.getReader();
				const data = {text: '', contentType: res.headers.get('Content-Type')};
				return await readChunk();
				async function readChunk(){
					return reader.read().then(appendChunks);
				}
				async function appendChunks(result){
					const done = Boolean(result.done);
					const chunk = decoder.decode(result.value || new Uint8Array(), {stream: !done});
					if (onRead) onRead({buffer: chunk, response: RESPONSE});
					data.text += chunk;
					if (!done) return readChunk();
					return data;
				}
			})
			.then(data => {
				const {contentType, text} = data;
				data.json = undefined;
				RESPONSE_DATA = data;
				if (String(contentType).toLowerCase().indexOf('application/json') > -1){
					try {
						data.json = JSON.parse(text);
					}
					catch (e){
						console.warn(`Error parsing json (${contentType}) text.`, e);
					}
				}
				if (!RESPONSE.ok || !(RESPONSE.status >= 200 && RESPONSE.status < 300)){
					let err = `Request error ${RESPONSE.status}: ${RESPONSE.statusText}`;
					console.warn(err, {RESPONSE, data})
					throw new Error(err);
				}
				return {error: undefined, data, response: RESPONSE};
			})
			.catch(error => Promise.reject({error, data: RESPONSE_DATA, response: RESPONSE}));
		};

		//fetch exec
		let ABORT_CONTROLLER, FETCH_EXEC = 0;
		const fetchAbort = () => ABORT_CONTROLLER?.abort?.();
		const fetchExec = async (cmd, is_cancel=false) => {
			
			//fetch busy
			let signal;
			if (!is_cancel){
				if (FETCH_EXEC) return console.warn('Fetch exec is busy.');
				FETCH_EXEC = 1;
				setDisabled(true);
				outputCmd(cmd);
				ABORT_CONTROLLER = new AbortController();
				signal = ABORT_CONTROLLER.signal;
			}

			//fetch request
			const formData = new FormData();
			formData.append('cmd', cmd);
			const options = {
				signal,
				method: 'POST',
				body: formData,
			};

			//result - fetch request promise
			return fetchRequest(ENDPOINT, options, ({buffer, response}) => {
				if (response.ok) outputText(buffer);
			})
			.catch(err => {
				if (err?.error instanceof Error){
					if (err.error.name !== 'AbortError') console.warn(err.error);
					return;
				}
				return Promise.reject(err);
			})
			.finally(() => {
				if (is_cancel) return;
				FETCH_EXEC = 0;
				if (IS_CANCELLED) return IS_CANCELLED();
				setDisabled(false);
				outputPrompt();
				input_cmd.focus();
			});
		}
		const fetchCancel = async () => {
			if (IS_CANCELLED) return console.warn('Fetch cancel is busy.');

			//cancel busy
			const callback = () => {
				setDisabled(false);
				outputPrompt();
				input_cmd.focus();
				IS_CANCELLED = undefined;
			};
			IS_CANCELLED = () => callback();
			setDisabled(true, true);
			outputCmd('cancel');

			//cancel fetch
			if (FETCH_EXEC){
				
				//aborting
				outputText('Aborting...\n');
				fetchAbort();
				
				//result - fetch request promise
				return fetchExec('cancel', true)
				.finally(() => {
					if (FETCH_EXEC) return;
					callback();
				});
			}

			//cancel done
			return callback();
		};

		//run test
		const runTest = () => {
			setDisabled(true);
			outputCmd('test');
			let x = 0, max = 100, interval = setInterval(() => {
				x ++;
				outputText(`[${x}/${max}] - test line.\n`);
				if (x === max || IS_CANCELLED){
					clearInterval(interval);
					if (IS_CANCELLED) return IS_CANCELLED();
					setDisabled(false);
					outputText(output_prompt);
				}
			}, 200);
		};

		//run actions
		const ACTIONS = {
			'cancel': () => fetchCancel(),
			'clear': () => {
				if (isDisabled()) return;
				fetchExec('clear')
				.then(() => {
					outputClear();
					input_cmd.value = '';
					input_cmd.focus();
				});
			},
			'exec': (cmd) => {
				if (isDisabled()) return;
				fetchExec(cmd);
			},
			'cmd': () => {
				if (isDisabled()) return;
				const cmd = input_cmd.value.trim();
				input_cmd.value = '';
				if (!cmd.length) return;
				let tmp = cmd.toLowerCase();
				if (ACTIONS.hasOwnProperty(tmp)) return ACTIONS[tmp]();
				return ACTIONS.exec(cmd);
			},
			'test': () => ACTIONS.exec('test'),
			'run-test': () => {
				if (isDisabled()) return;
				runTest();
			},
			'requirements': () => ACTIONS.exec('requirements'),
			'install-composer': () => ACTIONS.exec('install-composer'),
			'resume': () => ACTIONS.exec('resume'),
		};
		
		//action events
		cmd_form.addEventListener('submit', e => {
			e.preventDefault();
			ACTIONS.cmd();
		});
		btn_requirements.addEventListener('click', e => {
			e.preventDefault();
			ACTIONS.requirements();
		});
		btn_install_composer.addEventListener('click', e => {
			e.preventDefault();
			ACTIONS['install-composer']();
		});
		btn_clear.addEventListener('click', e => {
			e.preventDefault();
			ACTIONS.clear();
		});
		btn_cancel.addEventListener('click', e => {
			e.preventDefault();
			ACTIONS.cancel();
		});

		//initialize
		outputClear();
		input_cmd.placeholder = output_prompt;
		input_cmd.focus();
		setDisabled(false);

		//resume
		if (RESUME){
			console.debug('RESUME', RESUME);
			ACTIONS.resume();
		}
	</script>
</body>
</html>