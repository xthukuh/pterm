<?php

class Process
{
	/**
	 * exe suffixes.
	 * 
	 * @var array
	 */
	const EXE_SUFFIXES = ['.EXE', '.BAT', '.CMD', '.COM'];

	/**
	 * process options (proc_open args)
	 * 
	 * - REF: https://www.php.net/manual/en/function.proc-open.php
	 * 
	 * @var array
	 */
	const OPTIONS = [
		'descriptor_spec' => null,	//(array) file descriptors [default: self::DESCRIPTOR_SPEC]
		'cwd' => null,				//working directory [default: getcwd()]
		'env_vars' => null,			//(assoc array) environment variables
		'other_options' => null,	//(assoc array) other options [default (windows): self::WIN_OPTIONS]
	];

	/**
	 * default file descriptors
	 * 
	 * @var array
	 */
	const DESCRIPTOR_SPEC = [
		0 => ['pipe', 'r'],	//stdin
		1 => ['pipe', 'w'],	//stdout
		2 => ['pipe', 'w'],	//stderr
	];

	/**
	 * default windows platform options (other_options).
	 * 
	 * @var array
	 */
	const WIN_OPTIONS = [
		'suppress_errors' => false,			//suppresses errors generated by this function when it's set to true
		'bypass_shell' => false,			//bypass cmd.exe shell when set to true
		'blocking_pipes' => false,			//force blocking pipes when set to true
		'create_process_group' => false,	//allow the child process to handle CTRL events when set to true
		'create_new_console' => false,		//the new process has a new console, instead of inheriting its parent's console
	];
	
	/**
	 * verbose log mode (0=disabled, 1=all, 2=normal/high/error, 3=high/error, 4=error)
	 * 
	 * - TODO: for debugging: omit in final version 
	 * 
	 * @var int
	 */
	public static $VERBOSE = 0;

	/**
	 * verbose log file path
	 * 
	 * - TODO: for debugging: omit in final version 
	 * 
	 * @var string
	 */
	public static $LOG_FILE = '__process_verbose.log';

	/**
	 * process error message (if failed)
	 * 
	 * @var string
	 */
	private $_error;

	/**
	 * process state (one of: [null, 'failing', 'failed', 'opening', 'open', 'closing', 'closed', 'shutdown'])
	 * 
	 * @var string
	 */
	private $_state;

	/**
	 * process config data (see static::config())
	 * 
	 * @var array
	 */
	private $_config;

	/**
	 * process resource.
	 * 
	 * @var resource
	 */
	private $_process;

	/**
	 * process resource pipes
	 * 
	 * @var array
	 */
	private $_pipes;

	/**
	 * exit result code (proc_close() result)
	 * 
	 * @var int
	 */
	private $_exit;

	/**
	 * opened process ID (PID: end($this -> pids))
	 * 
	 * @var int
	 */
	private $_pid;

	/**
	 * opened processes ID (PID array)
	 * 
	 * @var array
	 */
	private $_pids;

	/**
	 * new instance
	 * 
	 * @param  string	$cmd		- command line string
	 * @param  array	$options	- process options (proc_open args)
	 * @param  bool		$background	- process runs in the background
	 * @return void
	 */
	public function __construct($cmd, $options=null, $background=false){
		$config = static::config($cmd, $options, $background, $_as_win=null, $error);
		if (!$config) $this -> _failure("Construct config failure: $error");
		else $this -> _config = $config;
	}

	/**
	 * verbose log
	 * 
	 * - TODO: for debugging: omit in final version 
	 * 
	 * @param  string	$message	- log message
	 * @param  int		$level		- log level (0=low, 1=normal, 2=high, 3=error)
	 * @return void
	 */
	private static function _verbose($message, $level=0){
		static $path;
		if (!$path) $path = is_string($tmp = self::$LOG_FILE) && ($tmp = trim($tmp)) ? $tmp : '__process_verbose.log';
		if (($verbose = (int) self::$VERBOSE) <= 0) return;
		if ($level < ($verbose - 1)) return;
		$datetime = (new DateTime()) -> format('Y-m-d H:i:s');
		$data = rtrim("[$datetime - $level] $message") . "\n";
		if (!@file_put_contents($path, $data, FILE_APPEND)) throw new Exception("Failed to append contents ($path)");
	}

	/**
	 * disable verbose for callback
	 * 
	 * @param  callable	$handler	- callback method
	 * @return void
	 */
	private static function _no_verbose($handler){
		if (!is_callable($handler)) return;
		$tmp = self::$VERBOSE;
		self::$VERBOSE = 0;
		try {
			call_user_func($handler);
			self::$VERBOSE = $tmp;
		}
		catch (Exception $e){
			self::$VERBOSE = $tmp;
			throw $e;
		}
	}

	/**
	 * handle process failure
	 * 
	 * @param  $error  - error message
	 * @return false
	 */
	private function _failure($error){
		if (self::$VERBOSE) static::_verbose("> FAILURE: $error", 3);
		$this -> _status = 'failing';
		$this -> close($_kill=1);
		$this -> _error = $error;
		$this -> _status = 'failed';
		return false;
	}
	
	/**
	 * get property value
	 * 
	 * @param  string  $name	- property name
	 * @return mixed
	 */
	public function __get($name){
		static $props = ['error', 'state', 'config', 'exit', 'pid', 'pids'];
		if (in_array($name, $props)){
			if (property_exists($this, $prop = "$name")) return $this -> {$prop};
			if (property_exists($this, $prop = "_$name")) return $this -> {$prop};
		}
		throw new Exception(sprintf('Property name "%s" is not available.', $name));
	}

	/**
	 * close process (proc_close)
	 * 
	 * @param  bool	$kill	- Kill running process.
	 * @return void
	 */
	public function close($kill=false){
		$kill = !!$kill;
		
		//closing
		if (strpos($state = $this -> _state, 'open') !== false) $this -> _state = $state = 'closing';
		elseif (strpos($state, 'clos') !== false) return; //ignore if closing/closed
		if (self::$VERBOSE) static::_verbose(sprintf('> $this -> close($kill=%s)', json_encode($kill)), 1);
		
		//kill running (temporarily disable debugging)
		if ($kill){
			$tmp = self::$VERBOSE;
			static::_no_verbose(function() use (&$tmp){
				if (is_array($pids = $this -> _pids) && ($len = count($pids))){
					for ($i = ($len - 1); $i >= 0; $i --){
						$pid = $pids[$i];
						$killed = static::kill($pid);
						if ($tmp){
							self::$VERBOSE = $tmp;
							static::_verbose(sprintf('- closing -> kill(pid=%s) = %s', $pid, json_encode($killed)));
							self::$VERBOSE = 0;
						}
					}
				}
			});
		}

		//close pipes
		if (is_array($this -> _pipes)){
			foreach ($this -> _pipes as $i => &$pipe){
				if (is_resource($pipe)){
					$res = fclose($pipe);
					if (self::$VERBOSE) static::_verbose(sprintf('- fclose($this -> _pipes[%s]) -> %s', $i, json_encode($res)));
				}
			}
			$this -> _pipes = null;
		}

		//close process
		if (is_resource($this -> _process)){
			$this -> _exit = $exit = proc_close($this -> _process);
			$this -> _process = null;
			if (self::$VERBOSE) static::_verbose(sprintf('- proc_close($this -> _process) -> %s', json_encode($exit)));
		}

		//closed state
		if ($state === 'closing') $this -> _state = 'closed';
	}

	/**
	 * shutdown open process
	 * 
	 * @return void
	 */
	public function shutdown(){
		if (strpos($state = $this -> _state, 'open') === false) return;
		if (self::$VERBOSE) static::_verbose(sprintf('> $this -> shutdown() - (state: %s)', $state), 1);
		$this -> _state = 'shutdown';
		$this -> close(1);
	}

	/**
	 * process status (proc_get_status).
	 * 
	 * @param  int  $pid		- ByRef process pid.
	 * @param  int  $running	- ByRef (int/bool) process is running.
	 * @return array
	 */
	public function status(&$pid=null, &$running=null){
		$pid = null;
		$running = null;
		$status = is_resource($this -> _process) && is_array($val = proc_get_status($this -> _process)) ? $val : [];
		if (array_key_exists($key = 'pid', $status) && ($val = static::pid($status[$key]))) $pid = $val;
		if (array_key_exists($key = 'running', $status)) $running = (int) (!!$status[$key]);
		return $status;
	}

	/**
	 * open process (proc_open)
	 * 
	 * ~ callback results
	 * - if callback returns true:	prevents running process close (you will need to call $self -> close() manually [automatically closed by shutdown handler])
	 * - if callback returns false:	kill/close running process
	 * 
	 * @param  callable	$open_callback	- process opened callback (i.e function(Process $self){...})
	 * @param  bool		$get_child		- sets PIDs ($self -> pids) if enabled - always enabled if $background is enabled.
	 * @return null|bool				- null if cancelled (ignored) | true on success | false on error
	 */
	public function open($open_callback=null, $get_child=false){
		$open_callback = is_callable($open_callback) ? $open_callback : null;
		$get_child = !!$get_child;

		//check config
		if (!($config = $this -> _config)) return $this -> _failure(trim('Open process config is undefined. ' . $this -> _error));
		if (($background = $config['background']) && !$get_child) $get_child = 'BG';

		//opening
		if (($state = $this -> _state) === 'opening') return; //ignore opening
		if (self::$VERBOSE){
			static::_verbose(sprintf('> $this -> open($open_callback=%s, $get_child=%s) %s', $open_callback ? 'callable' : 'null', is_string($get_child) ? $get_child : json_encode($get_child), $config['command']), 1);
			static::_verbose(sprintf('- config: %s', json_encode($config)));
		}
		if ($state === 'open') $this -> close(1); //close/kill open
		$this -> _state = 'opening';
		
		//reset props
		$this -> _process = null;
		$this -> _pipes = null;
		$this -> _exit = null;
		$this -> _pid = null;
		$this -> _pids = null;
		
		//open process
		$command = $config['command'];
		$this -> _process = proc_open($command, $config['descriptor_spec'], $this -> _pipes, $config['cwd'], $config['env_vars'], $config['other_options']);
		if (!is_resource($this -> _process)){
			if (self::$VERBOSE) static::_verbose("proc_open failure - error_get_last:\n" . print_r(error_get_last(), 1));
			return $this -> _failure(sprintf('Open process failure. (%s)', $command));
		}

		//opened process - status/pid
		if (!(!empty($this -> status($pid, $running)) && $pid)) return $this -> _failure(sprintf('Unable to get opened process status/pid. (%s)', $command));
		if (self::$VERBOSE) static::_verbose(sprintf('~ process opened (pid=%s, running=%s, mypid=%s)', $pid, $running, getmypid()), 1);
		
		//open state
		$this -> _state = 'open';
		
		//set PIDs
		$pids = [$pid];
		if ($get_child){
			if (!($child_pid = static::child($pid, $_pids, $err))){
				$this -> status($_pid, $_running);
				if ($_pid === $pid && !$_running) $running = 0; //ignore not running
				else return $this -> _failure(sprintf('Get child [%s] failure: %s (%s)', $pid, $err, $command));
			}
			$pids = array_merge($pids, $_pids);
			if ($child_pid) $pid = $child_pid;
		}
		$this -> _pid = $pid;
		$this -> _pids = $pids;

		//open callback
		$result = null;
		if ($open_callback){
			if (self::$VERBOSE) static::_verbose('- open callback');
			if (!$background) register_shutdown_function([$this, 'shutdown']);
			try {
				$result = call_user_func_array($open_callback, [$this]);
				if (self::$VERBOSE) static::_verbose(sprintf('- open callback result=%s', json_encode($result)));
			}
			catch (Exception $e){
				return $this -> _failure('Open callback exception: ' . $e -> getMessage());
			}
		}

		//close process
		if ($result === false) $this -> close(1);
		elseif ($result !== true) $this -> close();

		//success
		return true;
	}

	/**
	 * get running PID
	 * 
	 * @return int|null  - PID or null if not found
	 */
	public function running(){
		$running_pid = null;
		static::_no_verbose(function() use (&$running_pid){
			if (is_resource($this -> _process)){
				$this -> status($pid, $running);
				if ($running) $running_pid = $pid;
			}
			if (!$running_pid && is_array($this -> _pids)){
				foreach ($this -> _pids as $pid){
					if (static::exists($pid)){
						$running_pid = $pid;
						break;
					}
				}
			}
		});
		if (self::$VERBOSE) static::_verbose(sprintf('> $this -> running() = %s', json_encode($running_pid)), 1);
		return $running_pid;
	}

	/**
	 * get pipe resource
	 * 
	 * @param  int  $index	- pipe index (0 = stdin, 1 = stdout, 2 = stderr) [default=1].
	 * @return resource|null
	 */
	public function pipe($index=1){
		if (is_array($this -> _pipes) && isset($this -> _pipes[$index]) && is_resource($pipe = &$this -> _pipes[$index])) return $pipe;
	}

	/**
	 * close pipe resource
	 * 
	 * @param  int  $index	- pipe index (0 = stdin, 1 = stdout, 2 = stderr)
	 * @return bool			- success
	 */
	public function close_pipe($index){
		$result = true;
		if ($pipe = $this -> pipe($index)) $result = fclose($pipe);
		return $result;
	}

	/**
	 * process read output
	 * 
	 * @param  bool		$print				- buffer print
	 * @param  array	$buffer_callback	- buffer callback [return false to abort read] (i.e. function(string $buffer){...})
	 * @param  resource	$resource			- resource pipe/path [default: $this -> pipe(1)]
	 * @param  string	$error				- ByRef error message
	 * @param  int		$abort				- ByRef abort status (0=no abort, 1=callback abort, 2=connection abort)
	 * @return string|false					- read contents or false on error
	 */
	public function output($print=false, $buffer_callback=null, $resource=null, &$error=null, &$abort=null){
		$error = null;
		$abort = null;
		if (is_string($resource) && ($path = trim($resource))) return static::read_file($path, $this -> running(), $_seek=0, $print, $buffer_callback, $error, $abort);
		else if (is_resource($resource)) return static::read_pipe($resource, $print, $buffer_callback, $error, $abort);
		return static::read_pipe($this -> pipe(1), $print, $buffer_callback, $error, $abort);
	}

	/**
	 * is windows platform
	 * 
	 * @param  string  $uname - ByRef php_uname result
	 * @return bool
	 */
	public static function is_win(&$uname=null){
		static $_is_win, $_uname;
		if (!is_bool($_is_win)){
			$_is_win = stripos($_uname = php_uname('s'), 'win') > -1;
			if (self::$VERBOSE) static::_verbose(sprintf('> static::is_win(uname=%s) = %s', $_uname, json_encode($_is_win)));
		}
		$uname = $_uname;
		return $_is_win;
	}

	/**
	 * check if process is running on console.
	 * 
	 * @return int  - mode (0=not console, 1=non-interactive, 2=interactive)
	 */
	public static function is_console(){
		static $value;
		if (!is_integer($value)){
			$value = in_array(strtolower(php_sapi_name()), ['cli', 'phpdbg']) ? (defined('STDIN') && stream_isatty(STDIN) ? 2 : 1) : 0;
			if (self::$VERBOSE) static::_verbose(sprintf('> static::is_console() = %s', $value));
		}
		return $value;
	}

	/**
	 * parse process options
	 * 
	 * - result (see const OPTIONS)
	 * 
	 * @param  array	$options	- process options
	 * @param  bool		$as_win		- parse options for windows platform [default: static::is_win()]
	 * @param  string	$error		- ByRef error message
	 * @return array|false			- options array or false on error
	 */
	public static function options($options=null, $as_win=null, &$error=null){
		$error = null;
		try {
			
			//vars
			$opts = self::OPTIONS;
			$options = is_array($options) ? $options : [];
			$as_win = is_null($as_win) ? static::is_win() : !!$as_win;
			
			//helper method - check if value is an associative array
			$_is_assoc = function($val){
				return is_array($val) && ($c = count($val)) && array_keys($val) !== range(0, $c - 1);
			};
			
			//options - descriptor_spec
			$descriptor_spec = self::DESCRIPTOR_SPEC;
			if (array_key_exists($key = 'descriptor_spec', $options)){
				$descriptor_spec = [];
				if (!empty($val = $options[$key])){
					if (!is_array($val)) throw new Exception(sprintf('Options descriptor_spec value is not an array. ([%s] %s)', gettype($val), json_encode($val)));
					foreach ($val as $i => $v){
						if (!(is_integer($i) && $i >= 0)) throw new Exception(sprintf('Options descriptor_spec entry key is not a valid integer. ([%s] %s)', gettype($i), $i));
						if (is_array($v)) $descriptor_spec[$i] = $v;
						elseif (!empty($v)) throw new Exception(sprintf('Options descriptor_spec entry value is invalid. (%s => [%s] %s)', $i, gettype($v), json_encode($v)));
					}
				}
			}
			$opts[$key] = $descriptor_spec;
	
			//options - cwd
			$cwd = null;
			if (array_key_exists($key = 'cwd', $options)){
				if (!empty($val = $options[$key])){
					if (($path = realpath(trim($val))) === false) throw new Exception(sprintf('Options cwd value is not a real path. ([%s] %s)', gettype($val), $val));
					if (!is_dir($path)) throw new Exception(sprintf('Options cwd path value is not a directory. (%s)', $path));
					$cwd = $path;
				}
			}
			$opts[$key] = $cwd;

			//options - env_vars
			$env_vars = [];
			if (array_key_exists($key = 'env_vars', $options)){
				if (!empty($val = $options[$key])){
					if (!$_is_assoc($val)) throw new Exception(sprintf('Options env_vars value is not an associative array. ([%s] %s)', gettype($val), json_encode($val)));
					foreach ($val as $i => $v){
						if (!empty($v)) $env_vars[$i] = $v;
					}
				}
			}
			$opts[$key] = !empty($env_vars) ? $env_vars : null;

			//options - other_options
			$other_options = $as_win ? self::WIN_OPTIONS : [];
			if (array_key_exists($key = 'other_options', $options)){
				$other_options = [];
				if (!empty($val = $options[$key])){
					if (!$_is_assoc($val)) throw new Exception(sprintf('Options other_options value is not an associative array. ([%s] %s)', gettype($val), json_encode($val)));
					foreach ($val as $i => $v){
						if (!empty($v)) $other_options[$i] = $v;
					}
				}
			}
			$opts[$key] = !empty($other_options) ? $other_options : null;

			//result
			return $opts;
		}
		catch (Exception $e){
			$error = $e -> getMessage();
			return false;
		}
	}

	/**
	 * parse command line string
	 * 
	 * - result [
	 *    'cmd' => null,			//(string) normalized command line string
	 *    'cmd_bg' => null,			//(string) background command line string
	 *    'stdout' => null,			//(string) parsed command stdout (i.e. '> output.log')
	 *    'stdout_path' => null,	//(string) parsed command stdout path (i.e. 'output.log')
	 *    'stderr' => null,			//(string) parsed command stderr (i.e. '> error.log')
	 *    'stderr_path' => null,	//(string) parsed command stderr path (i.e. 'error.log')
	 *    'stderr_merge' => 0,		//(int/bool) whether command has 2>&1
	 * ];
	 * 
	 * - 'cmd_bg' format - windows platform: "start /b /separate [COMMAND] >nul 2>&1 &"
	 * - 'cmd_bg' format - other platform (linux/unix): "[COMMAND] >/dev/null 2>&1 & echo &!"
	 * 
	 * @param  string	$cmd	- command line string
	 * @param  bool		$as_win	- parse command for windows platform [default: static::is_win()]
	 * @param  string	$error	- ByRef error message
	 * @return array			- parsed command data or false on error
	 */
	public static function parse($cmd, $as_win=null, &$error=null){
		static $_get_output, $_quote_restore;
		$error = null;

		//check command - replace unusual whitespace
		if (!(is_string($cmd) && ($tmp = trim(str_replace(urldecode('%C2%A0'), ' ', $cmd))))){
			if (is_string($cmd) || is_null($cmd)) $error = 'Empty command line string.';
			else $error = sprintf('Invalid command line string. ([%s] %s)', gettype($cmd), json_encode($cmd));
			return false;
		}
		else $cmd = $tmp;
		
		//vars
		$as_win = is_null($as_win) ? static::is_win() : !!$as_win;
		$stdout_path = $stderr_path = $stdout = $stderr = $tmp = $stderr_merge = null;
		$s = $cmd;
		
		//backup quotes
		$q = -1;
		$quote = [];
		if (strpos($s, '\'') !== false || strpos($s, '"') !== false){
			
			//quote - "
			$s = preg_replace_callback('/\'([^\']+)\'/', function($match) use (&$quote, &$q){
				$q ++;
				$quote[$tmp = '__' . $q . '__'] = $match[0];
				return $tmp;
			}, $s);

			//quote - '
			$s = preg_replace_callback('/"([^"]+)"/', function($match) use (&$quote, &$q){
				$q ++;
				$quote[$tmp = '__' . $q . '__'] = $match[0];
				return $tmp;
			}, $s);

			//helper method - quote restore
			if (!$_quote_restore) $_quote_restore = function($str, $q, $quote){
				$i = $key = null;
				for ($i = $q; $i >= 0; $i --){
					$key = '__' . $i . '__';
					$str = str_replace($key, $quote[$key], $str);
				}
				unset($i, $key);
				return $str;
			};
		}

		//parse command pipe
		if (strpos($s, '>') !== false){
			$stdout_append = 0;
			$stderr_append = 0;

			//check stdout
			if (preg_match('/(1| )\>\>/', $s)) $stdout_append = 1;
			
			//check stderr
			if (preg_match('/2\>\>/', $s)) $stderr_append = 1;
			
			//normalize stdout/stderr
			$s = preg_replace('/\>+/', '>', $s);
			$s = preg_replace('/([^\>]+\=[12])\>/', '$1 >', $s);
			$s = preg_replace('/([^12]+)\>/', '$1-1>', $s, 1);
			$s = preg_replace('/([^12]+)\>/', '$1-2>', $s, 1);
			$s = preg_replace('/-([12])\>/', '$1>', $s, 1);
			$s = preg_replace('/&([12])\>/', '$1>', $s);
			$s = preg_replace('/([^\>]+)([12])\>/', '$1 $2>', $s);

			//trim extra whitespace
			$s = preg_replace('/[ ]+/', ' ', $s);
			$s = preg_replace('/\s*&([12])/', '&$1', $s);

			//has 2>&1 (merge stderr & stdout)
			if (strpos($s, '2>&1') !== false){
				$stderr_merge = 1;
				$s = trim(str_replace('2>&1', '', $s));
			}

			//helper method - get stdout/stderr path
			if (!$_get_output) $_get_output = function($_cmd, $_as_win, $_stderr_path=0){
				$a = $_stderr_path ? 2 : 1;
				$b = $_stderr_path ? 1 : 2;
				$p = $x = $d = $v = null;
				if (!(($p = strpos($_cmd, "$a>")) !== false && ($p += 2))) return;
				if (($p = strpos($_cmd, "$a>")) !== false && ($p += 2)){
					$x = ($x = strpos($_cmd, "$b>", $p)) !== false ? $x : (($x = strpos($_cmd, '>', $p)) !== false ? $x : -1);
					$v = ($d = $x < 0 ? 0 : $x - $p) ? substr($_cmd, $p, $d) : substr($_cmd, $p);
					if (!strlen($v = trim($v))) $v = null;
					elseif (!preg_match(sprintf('/^[^%s]*$/', preg_quote('*?"<>|:&', '/')), $v)) $v = null;
					elseif (in_array(strtolower($v), ['nul', 'null', '/dev/null'])) $v = $_as_win ? 'nul' : '/dev/null';
				}
				unset($a, $b, $p, $x, $d);
				return $v;
			};

			//set stdout/stderr
			$stdout_path = ($tmp = $_get_output($s, $as_win)) ? $tmp : null;
			$stderr_path = ($tmp = $_get_output($s, $as_win, 1)) ? $tmp : null;
			$stdout = $stdout_path ? ($stdout_append ? '>>' : '>') . $stdout_path : null;
			$stderr = $stderr_path ? '2' . ($stderr_append ? '>>' : '>') . $stderr_path : null;
			unset($stdout_append, $stderr_append);

			//remove stdout/stderr from command line
			$s = preg_match('/^(.+?(?=[0-9]*\>))/', $s, $matches) && count($matches) ? trim($matches[0]) : trim($s);
		}

		//restore quotes
		if ($q > -1 && !empty($quote) && $_quote_restore){
			$s = $_quote_restore($s, $q, $quote);
			if ($stdout) $stdout = $_quote_restore($stdout, $q, $quote);
			if ($stderr) $stderr = $_quote_restore($stderr, $q, $quote);
		}

		//set normalized/background command
		$bg = $s;
		if ($stdout){
			$s .= ($tmp = ' ' . $stdout);
			$bg .= $tmp;
		}
		else $bg .= ' >' . ($as_win ? 'nul' : '/dev/null');
		if ($stderr){
			$s .= ($tmp = ' ' . $stderr);
			$bg .= $tmp;
		}
		else {
			$s .= $stderr_merge ? ' 2>&1' : '';
			$bg .= ' 2>' . ($stderr_merge ? '&1' : ($as_win ? 'nul' : '/dev/null'));
		}

		//background command - platform format
		if ($as_win){
			if (preg_match($tmp = '/^(start\s*(\/b)?)((?![a-z]).+)$/i', $bg)) $bg = trim(preg_replace('/\s+/', ' ', preg_replace($tmp, '$3', $bg)));
			$bg = 'start /b /separate ' . $bg . ' &';
		}
		else $bg .= ' & echo $!';
		unset($tmp, $q, $quote);
		
		//result
		return [
			'cmd' => $s,
			'cmd_bg' => $bg,
			'stdout' => $stdout,
			'stdout_path' => $stdout_path,
			'stderr' => $stderr,
			'stderr_path' => $stderr_path,
			'stderr_merge' => $stderr_merge ? 1 : 0,
		];
	}

	/**
	 * get process config
	 * 
	 * result [
	 * 		'cmd' => null,				- (string) normalized command line
	 * 		'command' => null,			- (string) proc_open command line
	 * 		'stdout_path' => null,		- (string) parsed command line stdout path
	 * 		'stderr_path' => null,		- (string) parsed command line stderr path
	 * 		'background' => false,		- (bool) command runs in the background
	 * 		'as_win' => null,			- (bool) parsed for windows platform
	 * 		'descriptor_spec' => [],	- (array) options - proc_open file descriptors
	 * 		'cwd' => null,				- (string) options - proc_open working directory
	 * 		'env_vars' => null,			- (array) options - proc_open env_vars
	 * 		'other_options' => null,	- (array) options - proc_open other options
	 * ]
	 * 
	 * @param  string	$cmd		- command line string
	 * @param  array	$options	- process options (proc_open args)
	 * @param  bool		$background	- process runs in the background
	 * @param  bool		$as_win		- parse for windows platform [default: static::is_win()]
	 * @param  string	$error		- ByRef error message
	 * @return array|false			- config data or false on error.
	 */
	public static function config($cmd, $options=null, $background=false, $as_win=null, &$error=null){
		$error = null;

		//parse
		$as_win = is_null($as_win) ? static::is_win() : !!$as_win;
		if (!($parsed = static::parse($cmd, $as_win, $error))) return false;
		if (!($options = static::options($options, $error))) return false;

		//config
		$command = $cmd = $parsed['cmd'];
		$descriptor_spec = $options['descriptor_spec'];
		if ($background = !!$background){
			$command = $parsed['cmd_bg'];
			if ($as_win && count($descriptor_spec)) $descriptor_spec = array_slice($descriptor_spec, 0, 1); //only stdin (windows)
		}

		//result
		return [
			'cmd' => $cmd,
			'command' => $command,
			'stdout_path' => $parsed['stdout_path'],
			'stderr_path' => $parsed['stderr_path'],
			'background' => $background,
			'as_win' => $as_win,
			'descriptor_spec' => $descriptor_spec,
			'cwd' => $options['cwd'],
			'env_vars' => $options['env_vars'],
			'other_options' => $options['other_options'],
		];
	}

	/**
	 * PID validated integer
	 * 
	 * @param  int		$value	- validate PID value
	 * @param  string	$error	- ByRef error message
	 * @return int|false		- PID integer or false on failure
	 */
	public static function pid($value, &$error=null){
		$error = null;
		if (is_numeric($pid = trim($value)) && is_integer($pid = ($pid * 1)) && $pid > 0) return $pid;
		$error = sprintf('Invalid PID value. ([%s] %s)', gettype($value), json_encode($value));
		return false;
	}
	
	/**
	 * pid process child
	 * 
	 * @param  int		$pid	- PID (parent)
	 * @param  array	$pids	- descendant PIDs
	 * @param  string	$error	- ByRef error message
	 * @return int|null			- last descendant PID or false on failure
	 */
	public static function child($pid, &$pids=null, &$error=null){
		$pids = [];
		$error = null;

		//check pid
		if (!($pid = static::pid($pid, $error))) return false;

		//command line
		$is_win = static::is_win();
		if ($is_win) $cmd = sprintf('wmic process get parentprocessid,processid | findstr /i "%s"', $pid);
		else $cmd = sprintf('ps afx --ppid %s', $pid);

		//run command
		$out = null;
		$err = null;
		$exit = null;
		static::_no_verbose(function() use (&$out, &$cmd, &$err, &$exit){
			$out = static::run($cmd, $err, $exit);
		});
		if ($out === false){
			$error = "Pid [$pid] process child exec failure (exit=$exit): $err";
			return false;
		}

		//parse output pids
		$parsed = [];
		if ($out = trim($out)){
			$parsed = explode($is_win ? ' ' : "\n", $out);
			$parsed = array_map(function($val) use (&$is_win, &$cmd){
				if (!$is_win){
					if (strpos($val, $cmd) !== false) return null;
					if (!preg_match('/^\s*([0-9]+)\s*/', $val, $val)) return null;
					$val = $val[1];
				}
				else $val = trim($val);
				return $val && is_numeric($val) && ($val = (int) $val) > 0 ? $val : null;
			}, $parsed);
			$parsed = empty($parsed) ? [] : array_filter($parsed, function($val){
				return is_numeric($val) && trim((int) $val) === trim($val);
			});
			$parsed = empty($parsed) ? [] : array_values($parsed);
			if (!empty($parsed)){
			    if (in_array($pid, $parsed)){
			       $seen = 0;
			       $pids = array_filter($parsed, function($val) use (&$pid, &$seen){
    					if ($val === $pid){
    						$seen = 1;
    						return false;
    					}
					    return $seen;
				    });
			    }
				else $pids = $parsed;
				$pids = empty($pids) ? [] : array_values($pids);
			}
		}

		//result
		$result = ($len = count($pids)) ? $pids[$len - 1] : false;
		if (self::$VERBOSE) static::_verbose(sprintf('> static::child(pid=%s, pids=%s) -> (result=%s, parsed=%s, exit=%s) %s', $pid, json_encode($pids), json_encode($result), json_encode($parsed), $exit, "\ncmd=$cmd\nout=$out"), 1);
		if (!$result) $error = "Pid [$pid] process child not found.";
		return $result;
	}

	/**
	 * pid process exists
	 * 
	 * @param  int		$pid	- PID
	 * @param  string	$error	- ByRef error message
	 * @return int|false		- running PID | 0 nonexistent | false on error
	 */
	public static function exists($pid, &$error=null){
		$error = null;

		//check pid
		if (!($pid = static::pid($pid, $error))) return false;

		//command line
		if ($is_win = static::is_win()) $cmd = sprintf('tasklist /FI "PID eq %d" 2>&1', $pid);
		else $cmd = sprintf('ps -p %d -opid=,cmd= 2>&1', $pid);

		//run command
		$out = null;
		$err = null;
		$exit = null;
		static::_no_verbose(function() use (&$out, &$cmd, &$err, &$exit){
			$out = static::run($cmd, $err, $exit);
		});
		if ($out === false){
			$error = "Pid [$pid] process exists exec failure (exit=$exit): $err";
			return false;
		}

		//result
		$result = ($out = trim($out)) && strpos($out, "$pid") !== false ? $pid : 0;
		if (self::$VERBOSE) static::_verbose(sprintf('> static::exists(pid=%s) -> (result=%s, exit=%s) %s', $pid, json_encode($result), $exit, "\nout=" . $out), 1);
		return $result;
	}

	/**
	 * pid process kill
	 * 
	 * @param  int		$pid	- PID
	 * @param  string	$error	- ByRef error message
	 * @return int|false		- status (-1 = nonexistent, 1 = killed) or false on error
	 */
	public static function kill($pid, &$error=null){
		$error = null;

		//check pid
		if (!($pid = static::pid($pid, $error))) return false;

		//command line
		if ($is_win = static::is_win()) $cmd = sprintf('taskkill /F /T /PID %s 2>&1', $pid);
		else $cmd = sprintf('kill -s 9 %s 2>&1', $pid);

		//run command
		$out = null;
		$err = null;
		$exit = null;
		static::_no_verbose(function() use (&$out, &$cmd, &$err, &$exit){
			$out = static::run($cmd, $err, $exit);
		});
		if ($out === false){
			$error = "Pid [$pid] process kill exec failure (exit=$exit): $err";
			return false;
		}

		//parse output
		$result = null;
		if ($out = trim($out)){
			$result = 1;
			if ($is_win){
				if (stripos($out, 'no tasks') !== false || stripos($out, 'not found') !== false) $result = -1;
			}
			else if (stripos($out, 'no such process') !== false) $result = -1;
		}

		//verify dead
		if (!$result){
			$exists = null;
			static::_no_verbose(function() use (&$exists, &$pid){
				$exists = static::exists($pid);
			});
			if ($exists){
				$error = "Pid [$pid] process kill failed. (still running)";
				return false;
			}
			else $result = -1;
		}

		//result
		if (self::$VERBOSE) static::_verbose(sprintf('> static::kill(pid=%s) -> (result=%s, exit=%s)', $pid, $result, $exit), 1);
		return $result;
	}

	/**
	 * Timedout helper.
	 * 
	 * @param  float  $timeout  - Timeout seconds.
	 * @param  float  $start    - Start time seconds (microtime(1)).
	 * @param  float  $elapsed  - Seconds elapsed (microtime(1) - $start).
	 * @return bool
	 */
	public static function timedout($timeout=null, $start=null, &$elapsed=null){
		$timeout = is_numeric($timeout) && ($timeout = (float) $timeout) >= 0 ? $timeout : 0;
		$start = is_numeric($start) ? (float) $start : 0;
		$elapsed = microtime(1) - $start;
		return $elapsed >= $timeout;
	}

	/**
	 * Search for executable file.
	 * REF: https://github.com/symfony/process/blob/6.1/ExecutableFinder.php
	 * 
	 * @param  string		$name		- The executable name (without the extension) [Throws exception if undefined]
	 * @param  string|null	$default	- The default to return if no executable is found
	 * @param  array		$extraDirs	- Additional dirs to check into
	 * @return mixed					- (string executable file path | $default value)
	 */
	public static function find_exe($name, $default=null, $extraDirs=[]){
		static $suffixes;
		$dirs = [];
		$ps = PATH_SEPARATOR;
		if (!($name = trim($name))) throw new Exception('Undefined find_exe name.');
		if ($tmp = ini_get('open_basedir')){
			$searchPath = array_merge(explode($ps, $tmp), $extraDirs);
			foreach ($searchPath as $path){
				if (@is_dir($path)) $dirs[] = $path;
				elseif (strtolower(basename($path)) === strtolower($name) && @is_executable($path)) return $path;
			}
		}
		else $dirs = array_merge(explode($ps, getenv('PATH') ?: getenv('Path')), $extraDirs);
		$ds = DIRECTORY_SEPARATOR;
		if (!$suffixes){
			$suffixes = [''];
			if ('\\' === $ds){
				$pathExt = getenv('PATHEXT');
				$suffixes = array_merge($pathExt ? explode($ps, $pathExt) : self::EXE_SUFFIXES, $suffixes);
			}
		}
		foreach ($suffixes as $suffix){
			foreach ($dirs as $dir){
				if (@is_file($file = $dir.$ds.$name.strtolower($suffix)) && ('\\' === $ds || @is_executable($file))) return $file;
			}
		}
		return $default;
	}

	/**
	 * Find php executable binary.
	 * REF: https://github.com/symfony/process/blob/6.1/PhpExecutableFinder.php
	 * 
	 * @param  bool		$includeArgs	- Include runtime arguments (prevents cache if enabled)
	 * @return mixed					- (string php executable file path | false on error)
	 */
	public static function find_php($includeArgs=false){
		static $cached_exe;
		if (!$includeArgs && $cached_exe) return $cached_exe;
		$_phpExe = function($exe) use (&$cached_exe, &$includeArgs){
			if (!@is_executable($exe) || @is_dir($exe)) return false;
			if (!$includeArgs) $cached_exe = $exe;
			return $exe;
		};
		if (!static::is_win() && is_executable($php = '/usr/local/bin/php')) return $_phpExe($php);
		$ds = DIRECTORY_SEPARATOR;
		if ($php = getenv('PHP_BINARY')){
			if (!is_executable($php)){
				$command = '\\' === $ds ? 'where' : 'command -v';
				$command .= ' ' . escapeshellarg($php);
				$out = trim(static::run($command));
				if ($php = strtok($out, PHP_EOL)){
					if (!is_executable($php)) return false;
				}
				else return false;
			}
			return $_phpExe($php);
		}
		$args = [];
		if ('phpdbg' === PHP_SAPI) $args[] = '-qrr';
		$args = $includeArgs && $args ? ' '.implode(' ', $args) : '';
		if (($tmp = PHP_BINARY) && in_array(PHP_SAPI, ['cgi-fcgi', 'cli', 'cli-server', 'phpdbg'], true)) return $_phpExe($tmp.$args);
		if ($php = getenv('PHP_PATH')) return $_phpExe($php);
		if (($php = getenv('PHP_PEAR_PHP_BIN')) && @is_executable($php) && !@is_dir($php)) return $_phpExe($php);
		$bin_dir = PHP_BINDIR;
		if (@is_executable($php = $bin_dir.('\\' === $ds ? '\\php.exe' : '/php')) && !@is_dir($php)) return $_phpExe($php);
		$dirs = [$bin_dir];
		if ('\\' === $ds) $dirs[] = 'C:\xampp\php\\';
		return $_phpExe(static::find_exe('php', false, $dirs));
	}
	
	/**
	 * Poll callback helper.
	 * 
	 * @param  callable $poll_callback	- Polling callback (this should return truthy value to abort polling)
	 * @param  int		$sleep_ms		- Polling interval sleep microseconds [default 1000 (1 sec)] (minimum 100)
	 * @param  int		$timeout		- Polling timeout seconds. [default 10 sec] (0 = unlimited)
	 * @param  string	$error			- ByRef Polling error message
	 * @return bool						- Polling complete (false on error)
	 */
	public static function poll($poll_callback=null, $sleep_ms=1000, $timeout=10, &$error=null){
		$error = null;
		try {
			if (!is_callable($poll_callback)) throw new Exception('Polling callback is not callable.');
			$sleep_ms = is_integer($sleep_ms) && $sleep_ms >= 100 ? $sleep_ms : 1000;
			$timeout = is_integer($timeout) && $timeout >= 0 ? $timeout : 10;
			$start = microtime(1);
			while (true){
				if (call_user_func($poll_callback)) return true;
				if ($timeout && static::timedout($timeout, $start, $eta)) throw new Exception('Polling timed out.');
				usleep($sleep_ms * 1000);
			}
		}
		catch (Exception $e){
			$error = $e -> getMessage();
			return false;
		}
	}

	/**
	 * Poll process exists status.
	 * 
	 * @param  int		$pid			- Process PID
	 * @param  bool		$exists			- Poll check if PID process is running if enabled otherwise checks not running
	 * @param  callable $poll_callback	- Poll callback method called after failed check (aborts polling if callback returns truthy value)
	 * @param  int		$sleep_ms		- Polling interval sleep microseconds [default 1000 (1 sec)] (minimum 100)
	 * @param  int		$timeout		- Polling timeout seconds. [default 10 sec] (0 = unlimited)
	 * @param  string	$error			- ByRef Polling error message
	 * @return bool						- Polling complete (false on error)
	 */
	public static function poll_exists($pid, $exists=true, $poll_callback=null, $sleep_ms=1000, $timeout=10, &$error=null){
		$error = null;
		if (!($pid = static::pid($pid, $error))) return false;
		$poll_callback = is_callable($poll_callback) ? $poll_callback : null;
		return static::poll(function() use (&$pid, &$exists, &$poll_callback){
			$pid_exists = null;
			static::_no_verbose(function() use (&$pid_exists, &$pid){
				$pid_exists = static::exists($pid);
			});
			if (!!$pid_exists === !!$exists) return true;
			if ($poll_callback && call_user_func($poll_callback)) return true;
		}, $sleep_ms, $timeout, $error);
	}

	/**
	 * set no execution limit
	 * 
	 * ~ usage: $_restore = static::no_limit();
	 * ~ restore: $_restore();
	 * 
	 * @param  int	$ignore_abort	- ByRef previous value ignore_user_abort()
	 * @param  int	$max_time		- ByRef previous value max_execution_time
	 * @return Closure  - call to restore previous values
	 */
	public static function no_limit(&$ignore_abort=null, &$max_time=null){
		$ignore_abort = (int) ignore_user_abort();
		$max_time = (int) ini_get('max_execution_time');
		set_time_limit(0);
		ignore_user_abort(1);
		return function() use (&$ignore_abort, &$max_time){
			ignore_user_abort($ignore_abort);
			set_time_limit($max_time);
		};
	}

	/**
	 * output buffer end
	 * 
	 * @param  bool  $clean	- use method - ob_end_clean() if enabled [default: ob_end_flush()]
	 * @return bool			- method success
	 */
	public static function print_end($clean=false){
		$res = true;
		while (ob_get_level() && ($res = $clean ? ob_end_clean() : ob_end_flush()));
		return $res;
	}

	/**
	 * output buffer restart (end previous buffer if any - ob_start())
	 * 
	 * @param  bool  $clean	- ob_end_clean() if enabled [default: ob_end_flush()]
	 * @return bool			- ob_start() success
	 */
	public static function print_start($clean=false){
		static::print_end($clean);
		$res = true;
		if (!ob_get_level()) $res = ob_start();
		return $res;
	}

	/**
	 * print output
	 * 
	 * @param  string	$value	- print value.
	 * @param  bool		$br		- enable line break.
	 * @param  string	$str	- ByRef stringified print value (without buffer padding or line break)
	 * @return string			- output buffer
	 */
	public static function print_out($value, $br=true, &$str=null){
		
		//to string
		if (is_null($value) || is_bool($value) || is_object($value)) $value = json_encode($value);
		elseif (is_array($value)){
			$_arr_val = function($arr) use (&$_arr_val){
				$tmp = [];
				foreach ($arr as $key => $val){
					if (is_null($val) || is_bool($val) || is_object($val)) $val = json_encode($val);
					elseif (is_array($val)) $val = $_arr_val($val);
					$tmp[$key] = $val;
				}
				return $tmp;
			};
			$value = print_r($_arr_val($value), 1);
		}
		
		//string pad, break
		$str = $value;
		$reg = '/\r?\n[\t ]*$/s';
		$reg_match = preg_match($reg, $value, $matches);
		$pad_str = !static::is_win();
		if ($pad_str){
			$pad_size = 4096;
			$append = '';
			if ($reg_match){
				$pad_size -= strlen($append = $matches[0]);
				$value = preg_replace($reg, '', $value);
			}
			$value = str_pad($value, $pad_size, ' ', STR_PAD_RIGHT) . $append;
		}
		if ($br && !$reg_match) $value .= "\n";

		//print
		echo $value;
		ob_flush();
		flush();

		//result - buffer
		return $value;
	}

	/**
	 * read pipe resource buffer
	 * 
	 * @param  resource	$pipe				- resource pipe
	 * @param  bool		$print				- buffer print
	 * @param  array	$buffer_callback	- buffer callback [return false to abort read] (i.e. function(string $buffer){...})
	 * @param  string	$error				- ByRef error message
	 * @param  int		$abort				- ByRef abort status (0=no abort, 1=callback abort, 2=connection abort)
	 * @return string|false					- read contents or false on error
	 */
	public static function read_pipe($pipe, $print=false, $buffer_callback=null, &$error=null, &$abort=null){
		$error = null;
		$abort = 0;

		//check pipe
		if (!is_resource($pipe)){
			$error = 'Pipe resource is invalid.';
			return false;
		}

		//init
		$output = '';
		$read_size = 4096; //DEBUG: 1024
		$buffer_callback = is_callable($buffer_callback) ? $buffer_callback : null;
		$_restore = static::no_limit($ignore_abort);
		if ($print) static::print_start();
		
		//read loop
		while (!feof($pipe)){
			
			//read
			$buffer = fgets($pipe, $read_size);

			//buffer
			if (strlen($buffer)){
				
				//print
				if ($print) static::print_out($buffer, $_br=false, $buffer);
				
				//output
				$output .= $buffer;
				
				//callback
				if ($buffer_callback){
					try {
						if (call_user_func_array($buffer_callback, [$buffer]) === false){
							$abort = 1;
							break;
						}
					}
					catch (Exception $e){
						$_restore();
						$error = 'Read pipe callback failure: ' . $e -> getMessage();
						return false;
					}
				}

				//abort
				if (connection_aborted() && !$ignore_abort){
					$abort = 2;
					break;
				}
			}
		}

		//done - result
		$_restore();
		return $output;
	}

	/**
	 * read file resource buffer
	 * 
	 * @param  string	$path				- file path string
	 * @param  int		$pid				- related process Id (on read failure (eof), waits and retries read while process is still running)
	 * @param  int		$seek				- file read initial seek position [default=0]
	 * @param  bool		$print				- buffer print
	 * @param  array	$buffer_callback	- buffer callback [return false to abort read] (i.e. function(string $buffer){...})
	 * @param  string	$error				- ByRef error message
	 * @param  int		$abort				- ByRef abort status (0=no abort, 1=callback abort, 2=connection abort)
	 * @return string|false					- read contents or false on error
	 */
	public static function read_file($path, $pid=null, $seek=0, $print=false, $buffer_callback=null, &$error=null, &$abort=null){
		$error = null;
		$abort = 0;
		
		//check path
		if (!is_file($path)){
			$error = "File resource does not exist. ($path)";
			return false;
		}

		//init
		$output = '';
		$read_size = 4096; //DEBUG: 1024 * 8 (4096 * 2)
		$buffer_callback = is_callable($buffer_callback) ? $buffer_callback : null;
		$pid = is_numeric($pid) && ($pid = (int) $pid) >= 1 ? $pid : null;
		$seek = is_numeric($seek) && ($seek = (int) $seek) >= 0 ? $seek : 0;
		$_restore = static::no_limit($ignore_abort);
		if ($print) static::print_start();

		//try loop
		$stop = 0;
		$exists = 1;
		while (1){

			//open
			if (!is_file($path)) break;
			$pipe = @fopen($path, 'rb');
			if (!is_resource($pipe)) break;

			//stop reset
			if ($stop){
				if (($stat = fstat($pipe)) === false){
					$_restore();
					$error = "File resource fstat failure. ($path)";
					return false;
				}
				if ($stat['size'] > $seek) $stop = 1;
			}

			//seek
			if (fseek($pipe, $seek) < 0){
				$_restore();
				$error = "File resource fseek [$seek] failure. ($path)";
				return false;
			}

			//read loop
			while (!feof($pipe)){
				
				//read
				$buffer = fread($pipe, $read_size);

				//update seek
				if (($seek = ftell($pipe)) === false){
					$_restore();
					$error = "File resource ftell failure. ($path)";
					return false;
				}

				//buffer
				if (strlen($buffer)){

					//print
					if ($print) static::print_out($buffer, $_br=false, $buffer);

					//output
					$output .= $buffer;

					//callback
					if ($buffer_callback){
						try {
							if (call_user_func_array($buffer_callback, [$buffer]) === false){
								$abort = 1;
								break;
							}
						}
						catch (Exception $e){
							$_restore();
							$error = 'Read file callback failure: ' . $e -> getMessage();
							return false;
						}
					}

					//abort
					if (connection_aborted() && !$ignore_abort){
						$abort = 2;
						break;
					}
				}
			}

			//close
			fclose($pipe);

			//check stop/retry
			if (!$abort && $pid){
				if (!$stop) static::_no_verbose(function() use (&$exists, &$pid){
					$exists = static::exists($pid);
				});
				if (!$exists){
					$stop ++;
					if ($stop < 3){
						if ($stop > 1) usleep(500 * 1000);
						continue;
					}
				}
				else continue;
			}

			//break
			break;
		}

		//done
		$_restore();

		//result
		return $output;
	}

	/**
	 * run inline command - proc_open simple implementation
	 * 
	 * @param  string	$cmd				- Command line string
	 * @param  string	$error				- ByRef error message
	 * @param  int		$exit				- ByRef process exit code
	 * @param  array	$options			- process options (see static::options())
	 * @param  bool		$print				- buffer print
	 * @param  array	$buffer_callback	- buffer callback [return false to abort read] (i.e. function(string $buffer){...})
	 * @param  resource	$resource			- buffer read resource pipe/path [default: $proc -> pipe(1)]
	 * @param  int		$abort				- ByRef buffer abort status (0=no abort, 1=callback abort, 2=connection abort)
	 * @return string|false					- buffer output string or false on error
	 */
	public static function run($cmd, &$error=null, &$exit=null, $options=null, $print=false, $buffer_callback=null, $resource=null, &$abort=null){
		$error = null;
		$exit = null;
		$abort = null;
		$output = '';

		//open process
		$proc = new static($cmd, $options, false);
		$opened = $proc -> open(function($p) use (&$output, &$print, &$buffer_callback, &$resource, &$error, &$abort){
			$p -> close_pipe(0);
			$output = $p -> output($print, $buffer_callback, $resource, $error, $abort);
			if ($output === false) return false;
		});
		
		//close process
		$proc -> close();
		$exit = $proc -> exit;
		
		//failure
		if ($opened === false && !$error){
			$error = $proc -> error;
			$output = false;
		}

		//result
		if (self::$VERBOSE) static::_verbose(sprintf("> static::run(%s) (pid=%s, exit=%s, error=%s, abort=%s)\n%s", $cmd, $proc -> pid, $exit, $error, $abort, is_string($output) ? $output : json_encode($output)), 2);
		return $output;
	}

	/**
	 * Open background process helper.
	 * 
	 * @param  string	$cmd			- Command line (constructor argument 1)
	 * @param  string	$error			- ByRef failure error message
	 * @param  array	$options		- process options (see static::options())
	 * @param  callable	$open_callback	- Process -> open() callback method (i.e. function(Process $arg){})
	 * @param  string	$pid_file		- Background process PID cache file path
	 * @param  bool		$resume			- Enable background process resume if cached PID is still running
	 * @param  int		$resumed		- ByRef resumed status (1 = process was resumed, 0 = new process, null = failure)
	 * @return int|false				- Background process PID or false on Process -> open() failure.
	 */
	public static function run_bg($cmd, &$error=null, $options=null, $open_callback=null, $pid_file=null, $resume=true, &$resumed=null){
		$file = null;
		$error = null;
		$resumed = 0;

		//check cached pid process - resume running
		if (is_string($pid_file) && ($pid_file = trim($pid_file))) $file = $pid_file;
		if ($resume && is_file($file) && ($pid = file_get_contents($file)) !== false){
			$exists = null;
			static::_no_verbose(function() use (&$exists, &$pid){
				$exists = static::exists($pid);
			});
			if ($exists){
				$resumed = 1;
				return $pid;
			}
		}

		//open background process
		$proc = new static($cmd, $options, true);
		if (!$proc -> open($open_callback)){
			$error = $proc -> error;
			return false;
		}

		//close parent
		$proc -> close();

		//cache pid
		$pid = $proc -> pid;
		if ($file && !file_put_contents($file, "$pid")){
			$error = "Process run cache PID failure! ($file)";
			$proc -> close(1);
			return false;
		}

		//result
		return $pid;
	}
}